// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_session_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_session_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/struct.pb.h>
#include "core.pb.h"
#include "options.pb.h"
#include "style.pb.h"
#include "declarativeui.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_session_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_session_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[16]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_session_2eproto;
namespace xviz {
class CameraInfo;
class CameraInfoDefaultTypeInternal;
extern CameraInfoDefaultTypeInternal _CameraInfo_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class LogInfo;
class LogInfoDefaultTypeInternal;
extern LogInfoDefaultTypeInternal _LogInfo_default_instance_;
class Metadata;
class MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_CamerasEntry_DoNotUse;
class Metadata_CamerasEntry_DoNotUseDefaultTypeInternal;
extern Metadata_CamerasEntry_DoNotUseDefaultTypeInternal _Metadata_CamerasEntry_DoNotUse_default_instance_;
class Metadata_StreamAliasesEntry_DoNotUse;
class Metadata_StreamAliasesEntry_DoNotUseDefaultTypeInternal;
extern Metadata_StreamAliasesEntry_DoNotUseDefaultTypeInternal _Metadata_StreamAliasesEntry_DoNotUse_default_instance_;
class Metadata_StreamsEntry_DoNotUse;
class Metadata_StreamsEntry_DoNotUseDefaultTypeInternal;
extern Metadata_StreamsEntry_DoNotUseDefaultTypeInternal _Metadata_StreamsEntry_DoNotUse_default_instance_;
class Metadata_UiConfigEntry_DoNotUse;
class Metadata_UiConfigEntry_DoNotUseDefaultTypeInternal;
extern Metadata_UiConfigEntry_DoNotUseDefaultTypeInternal _Metadata_UiConfigEntry_DoNotUse_default_instance_;
class Reconfigure;
class ReconfigureDefaultTypeInternal;
extern ReconfigureDefaultTypeInternal _Reconfigure_default_instance_;
class Start;
class StartDefaultTypeInternal;
extern StartDefaultTypeInternal _Start_default_instance_;
class StateUpdate;
class StateUpdateDefaultTypeInternal;
extern StateUpdateDefaultTypeInternal _StateUpdate_default_instance_;
class StreamMetadata;
class StreamMetadataDefaultTypeInternal;
extern StreamMetadataDefaultTypeInternal _StreamMetadata_default_instance_;
class TransformLog;
class TransformLogDefaultTypeInternal;
extern TransformLogDefaultTypeInternal _TransformLog_default_instance_;
class TransformLogDone;
class TransformLogDoneDefaultTypeInternal;
extern TransformLogDoneDefaultTypeInternal _TransformLogDone_default_instance_;
class TransformPointInTime;
class TransformPointInTimeDefaultTypeInternal;
extern TransformPointInTimeDefaultTypeInternal _TransformPointInTime_default_instance_;
class UIPanelInfo;
class UIPanelInfoDefaultTypeInternal;
extern UIPanelInfoDefaultTypeInternal _UIPanelInfo_default_instance_;
}  // namespace xviz
PROTOBUF_NAMESPACE_OPEN
template<> ::xviz::CameraInfo* Arena::CreateMaybeMessage<::xviz::CameraInfo>(Arena*);
template<> ::xviz::Error* Arena::CreateMaybeMessage<::xviz::Error>(Arena*);
template<> ::xviz::LogInfo* Arena::CreateMaybeMessage<::xviz::LogInfo>(Arena*);
template<> ::xviz::Metadata* Arena::CreateMaybeMessage<::xviz::Metadata>(Arena*);
template<> ::xviz::Metadata_CamerasEntry_DoNotUse* Arena::CreateMaybeMessage<::xviz::Metadata_CamerasEntry_DoNotUse>(Arena*);
template<> ::xviz::Metadata_StreamAliasesEntry_DoNotUse* Arena::CreateMaybeMessage<::xviz::Metadata_StreamAliasesEntry_DoNotUse>(Arena*);
template<> ::xviz::Metadata_StreamsEntry_DoNotUse* Arena::CreateMaybeMessage<::xviz::Metadata_StreamsEntry_DoNotUse>(Arena*);
template<> ::xviz::Metadata_UiConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::xviz::Metadata_UiConfigEntry_DoNotUse>(Arena*);
template<> ::xviz::Reconfigure* Arena::CreateMaybeMessage<::xviz::Reconfigure>(Arena*);
template<> ::xviz::Start* Arena::CreateMaybeMessage<::xviz::Start>(Arena*);
template<> ::xviz::StateUpdate* Arena::CreateMaybeMessage<::xviz::StateUpdate>(Arena*);
template<> ::xviz::StreamMetadata* Arena::CreateMaybeMessage<::xviz::StreamMetadata>(Arena*);
template<> ::xviz::TransformLog* Arena::CreateMaybeMessage<::xviz::TransformLog>(Arena*);
template<> ::xviz::TransformLogDone* Arena::CreateMaybeMessage<::xviz::TransformLogDone>(Arena*);
template<> ::xviz::TransformPointInTime* Arena::CreateMaybeMessage<::xviz::TransformPointInTime>(Arena*);
template<> ::xviz::UIPanelInfo* Arena::CreateMaybeMessage<::xviz::UIPanelInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xviz {

enum Start_MessageFormat : int {
  Start_MessageFormat_START_MESSAGE_FORMAT_INVALID = 0,
  Start_MessageFormat_JSON = 1,
  Start_MessageFormat_BINARY = 2,
  Start_MessageFormat_Start_MessageFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Start_MessageFormat_Start_MessageFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Start_MessageFormat_IsValid(int value);
constexpr Start_MessageFormat Start_MessageFormat_MessageFormat_MIN = Start_MessageFormat_START_MESSAGE_FORMAT_INVALID;
constexpr Start_MessageFormat Start_MessageFormat_MessageFormat_MAX = Start_MessageFormat_BINARY;
constexpr int Start_MessageFormat_MessageFormat_ARRAYSIZE = Start_MessageFormat_MessageFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Start_MessageFormat_descriptor();
template<typename T>
inline const std::string& Start_MessageFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Start_MessageFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Start_MessageFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Start_MessageFormat_descriptor(), enum_t_value);
}
inline bool Start_MessageFormat_Parse(
    const std::string& name, Start_MessageFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Start_MessageFormat>(
    Start_MessageFormat_descriptor(), name, value);
}
enum StateUpdate_UpdateType : int {
  StateUpdate_UpdateType_STATE_UPDATE_UPDATE_TYPE_INVALID = 0,
  StateUpdate_UpdateType_SNAPSHOT = 1,
  StateUpdate_UpdateType_INCREMENTAL = 2,
  StateUpdate_UpdateType_COMPLETE_STATE = 3,
  StateUpdate_UpdateType_PERSISTENT = 4,
  StateUpdate_UpdateType_StateUpdate_UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StateUpdate_UpdateType_StateUpdate_UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StateUpdate_UpdateType_IsValid(int value);
constexpr StateUpdate_UpdateType StateUpdate_UpdateType_UpdateType_MIN = StateUpdate_UpdateType_STATE_UPDATE_UPDATE_TYPE_INVALID;
constexpr StateUpdate_UpdateType StateUpdate_UpdateType_UpdateType_MAX = StateUpdate_UpdateType_PERSISTENT;
constexpr int StateUpdate_UpdateType_UpdateType_ARRAYSIZE = StateUpdate_UpdateType_UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StateUpdate_UpdateType_descriptor();
template<typename T>
inline const std::string& StateUpdate_UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StateUpdate_UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StateUpdate_UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StateUpdate_UpdateType_descriptor(), enum_t_value);
}
inline bool StateUpdate_UpdateType_Parse(
    const std::string& name, StateUpdate_UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StateUpdate_UpdateType>(
    StateUpdate_UpdateType_descriptor(), name, value);
}
enum Reconfigure_UpdateType : int {
  Reconfigure_UpdateType_RECONFIGURE_UPDATE_TYPE_INVALID = 0,
  Reconfigure_UpdateType_DELTA = 1,
  Reconfigure_UpdateType_FULL = 2,
  Reconfigure_UpdateType_Reconfigure_UpdateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Reconfigure_UpdateType_Reconfigure_UpdateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Reconfigure_UpdateType_IsValid(int value);
constexpr Reconfigure_UpdateType Reconfigure_UpdateType_UpdateType_MIN = Reconfigure_UpdateType_RECONFIGURE_UPDATE_TYPE_INVALID;
constexpr Reconfigure_UpdateType Reconfigure_UpdateType_UpdateType_MAX = Reconfigure_UpdateType_FULL;
constexpr int Reconfigure_UpdateType_UpdateType_ARRAYSIZE = Reconfigure_UpdateType_UpdateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reconfigure_UpdateType_descriptor();
template<typename T>
inline const std::string& Reconfigure_UpdateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Reconfigure_UpdateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Reconfigure_UpdateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Reconfigure_UpdateType_descriptor(), enum_t_value);
}
inline bool Reconfigure_UpdateType_Parse(
    const std::string& name, Reconfigure_UpdateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Reconfigure_UpdateType>(
    Reconfigure_UpdateType_descriptor(), name, value);
}
enum StreamMetadata_Category : int {
  StreamMetadata_Category_STREAM_METADATA_CATEGORY_INVALID = 0,
  StreamMetadata_Category_PRIMITIVE = 1,
  StreamMetadata_Category_TIME_SERIES = 2,
  StreamMetadata_Category_VARIABLE = 3,
  StreamMetadata_Category_ANNOTATION = 4,
  StreamMetadata_Category_FUTURE_INSTANCE = 5,
  StreamMetadata_Category_POSE = 6,
  StreamMetadata_Category_UI_PRIMITIVE = 7,
  StreamMetadata_Category_StreamMetadata_Category_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_Category_StreamMetadata_Category_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_Category_IsValid(int value);
constexpr StreamMetadata_Category StreamMetadata_Category_Category_MIN = StreamMetadata_Category_STREAM_METADATA_CATEGORY_INVALID;
constexpr StreamMetadata_Category StreamMetadata_Category_Category_MAX = StreamMetadata_Category_UI_PRIMITIVE;
constexpr int StreamMetadata_Category_Category_ARRAYSIZE = StreamMetadata_Category_Category_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_Category_descriptor();
template<typename T>
inline const std::string& StreamMetadata_Category_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_Category>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_Category_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_Category_descriptor(), enum_t_value);
}
inline bool StreamMetadata_Category_Parse(
    const std::string& name, StreamMetadata_Category* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_Category>(
    StreamMetadata_Category_descriptor(), name, value);
}
enum StreamMetadata_ScalarType : int {
  StreamMetadata_ScalarType_STREAM_METADATA_SCALAR_TYPE_INVALID = 0,
  StreamMetadata_ScalarType_FLOAT = 1,
  StreamMetadata_ScalarType_INT32 = 2,
  StreamMetadata_ScalarType_STRING = 3,
  StreamMetadata_ScalarType_BOOL = 4,
  StreamMetadata_ScalarType_StreamMetadata_ScalarType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_ScalarType_StreamMetadata_ScalarType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_ScalarType_IsValid(int value);
constexpr StreamMetadata_ScalarType StreamMetadata_ScalarType_ScalarType_MIN = StreamMetadata_ScalarType_STREAM_METADATA_SCALAR_TYPE_INVALID;
constexpr StreamMetadata_ScalarType StreamMetadata_ScalarType_ScalarType_MAX = StreamMetadata_ScalarType_BOOL;
constexpr int StreamMetadata_ScalarType_ScalarType_ARRAYSIZE = StreamMetadata_ScalarType_ScalarType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_ScalarType_descriptor();
template<typename T>
inline const std::string& StreamMetadata_ScalarType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_ScalarType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_ScalarType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_ScalarType_descriptor(), enum_t_value);
}
inline bool StreamMetadata_ScalarType_Parse(
    const std::string& name, StreamMetadata_ScalarType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_ScalarType>(
    StreamMetadata_ScalarType_descriptor(), name, value);
}
enum StreamMetadata_PrimitiveType : int {
  StreamMetadata_PrimitiveType_STREAM_METADATA_PRIMITIVE_TYPE_INVALID = 0,
  StreamMetadata_PrimitiveType_CIRCLE = 1,
  StreamMetadata_PrimitiveType_IMAGE = 2,
  StreamMetadata_PrimitiveType_POINT = 3,
  StreamMetadata_PrimitiveType_POLYGON = 4,
  StreamMetadata_PrimitiveType_POLYLINE = 5,
  StreamMetadata_PrimitiveType_STADIUM = 6,
  StreamMetadata_PrimitiveType_TEXT = 7,
  StreamMetadata_PrimitiveType_StreamMetadata_PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_PrimitiveType_StreamMetadata_PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_PrimitiveType_IsValid(int value);
constexpr StreamMetadata_PrimitiveType StreamMetadata_PrimitiveType_PrimitiveType_MIN = StreamMetadata_PrimitiveType_STREAM_METADATA_PRIMITIVE_TYPE_INVALID;
constexpr StreamMetadata_PrimitiveType StreamMetadata_PrimitiveType_PrimitiveType_MAX = StreamMetadata_PrimitiveType_TEXT;
constexpr int StreamMetadata_PrimitiveType_PrimitiveType_ARRAYSIZE = StreamMetadata_PrimitiveType_PrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_PrimitiveType_descriptor();
template<typename T>
inline const std::string& StreamMetadata_PrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_PrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_PrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_PrimitiveType_descriptor(), enum_t_value);
}
inline bool StreamMetadata_PrimitiveType_Parse(
    const std::string& name, StreamMetadata_PrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_PrimitiveType>(
    StreamMetadata_PrimitiveType_descriptor(), name, value);
}
enum StreamMetadata_UIPrimitiveType : int {
  StreamMetadata_UIPrimitiveType_STREAM_METADATA_UI_PRIMITIVE_TYPE_INVALID = 0,
  StreamMetadata_UIPrimitiveType_TREETABLE = 1,
  StreamMetadata_UIPrimitiveType_StreamMetadata_UIPrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_UIPrimitiveType_StreamMetadata_UIPrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_UIPrimitiveType_IsValid(int value);
constexpr StreamMetadata_UIPrimitiveType StreamMetadata_UIPrimitiveType_UIPrimitiveType_MIN = StreamMetadata_UIPrimitiveType_STREAM_METADATA_UI_PRIMITIVE_TYPE_INVALID;
constexpr StreamMetadata_UIPrimitiveType StreamMetadata_UIPrimitiveType_UIPrimitiveType_MAX = StreamMetadata_UIPrimitiveType_TREETABLE;
constexpr int StreamMetadata_UIPrimitiveType_UIPrimitiveType_ARRAYSIZE = StreamMetadata_UIPrimitiveType_UIPrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_UIPrimitiveType_descriptor();
template<typename T>
inline const std::string& StreamMetadata_UIPrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_UIPrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_UIPrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_UIPrimitiveType_descriptor(), enum_t_value);
}
inline bool StreamMetadata_UIPrimitiveType_Parse(
    const std::string& name, StreamMetadata_UIPrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_UIPrimitiveType>(
    StreamMetadata_UIPrimitiveType_descriptor(), name, value);
}
enum StreamMetadata_AnnotationType : int {
  StreamMetadata_AnnotationType_STREAM_METADATA_ANNOTATION_TYPE_INVALID = 0,
  StreamMetadata_AnnotationType_VISUAL = 1,
  StreamMetadata_AnnotationType_StreamMetadata_AnnotationType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_AnnotationType_StreamMetadata_AnnotationType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_AnnotationType_IsValid(int value);
constexpr StreamMetadata_AnnotationType StreamMetadata_AnnotationType_AnnotationType_MIN = StreamMetadata_AnnotationType_STREAM_METADATA_ANNOTATION_TYPE_INVALID;
constexpr StreamMetadata_AnnotationType StreamMetadata_AnnotationType_AnnotationType_MAX = StreamMetadata_AnnotationType_VISUAL;
constexpr int StreamMetadata_AnnotationType_AnnotationType_ARRAYSIZE = StreamMetadata_AnnotationType_AnnotationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_AnnotationType_descriptor();
template<typename T>
inline const std::string& StreamMetadata_AnnotationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_AnnotationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_AnnotationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_AnnotationType_descriptor(), enum_t_value);
}
inline bool StreamMetadata_AnnotationType_Parse(
    const std::string& name, StreamMetadata_AnnotationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_AnnotationType>(
    StreamMetadata_AnnotationType_descriptor(), name, value);
}
enum StreamMetadata_CoordinateType : int {
  StreamMetadata_CoordinateType_STREAM_METADATA_COORDINATE_TYPE_INVALID = 0,
  StreamMetadata_CoordinateType_GEOGRAPHIC = 1,
  StreamMetadata_CoordinateType_IDENTITY = 2,
  StreamMetadata_CoordinateType_DYNAMIC = 3,
  StreamMetadata_CoordinateType_VEHICLE_RELATIVE = 4,
  StreamMetadata_CoordinateType_StreamMetadata_CoordinateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  StreamMetadata_CoordinateType_StreamMetadata_CoordinateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool StreamMetadata_CoordinateType_IsValid(int value);
constexpr StreamMetadata_CoordinateType StreamMetadata_CoordinateType_CoordinateType_MIN = StreamMetadata_CoordinateType_STREAM_METADATA_COORDINATE_TYPE_INVALID;
constexpr StreamMetadata_CoordinateType StreamMetadata_CoordinateType_CoordinateType_MAX = StreamMetadata_CoordinateType_VEHICLE_RELATIVE;
constexpr int StreamMetadata_CoordinateType_CoordinateType_ARRAYSIZE = StreamMetadata_CoordinateType_CoordinateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StreamMetadata_CoordinateType_descriptor();
template<typename T>
inline const std::string& StreamMetadata_CoordinateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamMetadata_CoordinateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamMetadata_CoordinateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StreamMetadata_CoordinateType_descriptor(), enum_t_value);
}
inline bool StreamMetadata_CoordinateType_Parse(
    const std::string& name, StreamMetadata_CoordinateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StreamMetadata_CoordinateType>(
    StreamMetadata_CoordinateType_descriptor(), name, value);
}
enum SessionType : int {
  SESSION_TYPE_INVALID = 0,
  LIVE = 1,
  LOG = 2,
  UNBUFFERED_LOG = 3,
  SessionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SessionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SessionType_IsValid(int value);
constexpr SessionType SessionType_MIN = SESSION_TYPE_INVALID;
constexpr SessionType SessionType_MAX = UNBUFFERED_LOG;
constexpr int SessionType_ARRAYSIZE = SessionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionType_descriptor();
template<typename T>
inline const std::string& SessionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionType_descriptor(), enum_t_value);
}
inline bool SessionType_Parse(
    const std::string& name, SessionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionType>(
    SessionType_descriptor(), name, value);
}
// ===================================================================

class Start :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.Start) */ {
 public:
  Start();
  virtual ~Start();

  Start(const Start& from);
  Start(Start&& from) noexcept
    : Start() {
    *this = ::std::move(from);
  }

  inline Start& operator=(const Start& from) {
    CopyFrom(from);
    return *this;
  }
  inline Start& operator=(Start&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Start& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Start* internal_default_instance() {
    return reinterpret_cast<const Start*>(
               &_Start_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Start& a, Start& b) {
    a.Swap(&b);
  }
  inline void Swap(Start* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Start* New() const final {
    return CreateMaybeMessage<Start>(nullptr);
  }

  Start* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Start>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Start& from);
  void MergeFrom(const Start& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Start* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.Start";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Start_MessageFormat MessageFormat;
  static constexpr MessageFormat START_MESSAGE_FORMAT_INVALID =
    Start_MessageFormat_START_MESSAGE_FORMAT_INVALID;
  static constexpr MessageFormat JSON =
    Start_MessageFormat_JSON;
  static constexpr MessageFormat BINARY =
    Start_MessageFormat_BINARY;
  static inline bool MessageFormat_IsValid(int value) {
    return Start_MessageFormat_IsValid(value);
  }
  static constexpr MessageFormat MessageFormat_MIN =
    Start_MessageFormat_MessageFormat_MIN;
  static constexpr MessageFormat MessageFormat_MAX =
    Start_MessageFormat_MessageFormat_MAX;
  static constexpr int MessageFormat_ARRAYSIZE =
    Start_MessageFormat_MessageFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageFormat_descriptor() {
    return Start_MessageFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageFormat_Name.");
    return Start_MessageFormat_Name(enum_t_value);
  }
  static inline bool MessageFormat_Parse(const std::string& name,
      MessageFormat* value) {
    return Start_MessageFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kProfileFieldNumber = 2,
    kLogFieldNumber = 5,
    kSessionTypeFieldNumber = 3,
    kMessageFormatFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string profile = 2;
  void clear_profile();
  const std::string& profile() const;
  void set_profile(const std::string& value);
  void set_profile(std::string&& value);
  void set_profile(const char* value);
  void set_profile(const char* value, size_t size);
  std::string* mutable_profile();
  std::string* release_profile();
  void set_allocated_profile(std::string* profile);
  private:
  const std::string& _internal_profile() const;
  void _internal_set_profile(const std::string& value);
  std::string* _internal_mutable_profile();
  public:

  // string log = 5;
  void clear_log();
  const std::string& log() const;
  void set_log(const std::string& value);
  void set_log(std::string&& value);
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  std::string* mutable_log();
  std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // .xviz.SessionType session_type = 3;
  void clear_session_type();
  ::xviz::SessionType session_type() const;
  void set_session_type(::xviz::SessionType value);
  private:
  ::xviz::SessionType _internal_session_type() const;
  void _internal_set_session_type(::xviz::SessionType value);
  public:

  // .xviz.Start.MessageFormat message_format = 4;
  void clear_message_format();
  ::xviz::Start_MessageFormat message_format() const;
  void set_message_format(::xviz::Start_MessageFormat value);
  private:
  ::xviz::Start_MessageFormat _internal_message_format() const;
  void _internal_set_message_format(::xviz::Start_MessageFormat value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.Start)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr profile_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  int session_type_;
  int message_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class TransformLog :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.TransformLog) */ {
 public:
  TransformLog();
  virtual ~TransformLog();

  TransformLog(const TransformLog& from);
  TransformLog(TransformLog&& from) noexcept
    : TransformLog() {
    *this = ::std::move(from);
  }

  inline TransformLog& operator=(const TransformLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformLog& operator=(TransformLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransformLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformLog* internal_default_instance() {
    return reinterpret_cast<const TransformLog*>(
               &_TransformLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TransformLog& a, TransformLog& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformLog* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransformLog* New() const final {
    return CreateMaybeMessage<TransformLog>(nullptr);
  }

  TransformLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransformLog>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransformLog& from);
  void MergeFrom(const TransformLog& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformLog* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.TransformLog";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDesiredStreamsFieldNumber = 4,
    kIdFieldNumber = 1,
    kStartTimestampFieldNumber = 2,
    kEndTimestampFieldNumber = 3,
  };
  // repeated string desired_streams = 4;
  int desired_streams_size() const;
  private:
  int _internal_desired_streams_size() const;
  public:
  void clear_desired_streams();
  const std::string& desired_streams(int index) const;
  std::string* mutable_desired_streams(int index);
  void set_desired_streams(int index, const std::string& value);
  void set_desired_streams(int index, std::string&& value);
  void set_desired_streams(int index, const char* value);
  void set_desired_streams(int index, const char* value, size_t size);
  std::string* add_desired_streams();
  void add_desired_streams(const std::string& value);
  void add_desired_streams(std::string&& value);
  void add_desired_streams(const char* value);
  void add_desired_streams(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& desired_streams() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_desired_streams();
  private:
  const std::string& _internal_desired_streams(int index) const;
  std::string* _internal_add_desired_streams();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // double start_timestamp = 2;
  void clear_start_timestamp();
  double start_timestamp() const;
  void set_start_timestamp(double value);
  private:
  double _internal_start_timestamp() const;
  void _internal_set_start_timestamp(double value);
  public:

  // double end_timestamp = 3;
  void clear_end_timestamp();
  double end_timestamp() const;
  void set_end_timestamp(double value);
  private:
  double _internal_end_timestamp() const;
  void _internal_set_end_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.TransformLog)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> desired_streams_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  double start_timestamp_;
  double end_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class StateUpdate :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.StateUpdate) */ {
 public:
  StateUpdate();
  virtual ~StateUpdate();

  StateUpdate(const StateUpdate& from);
  StateUpdate(StateUpdate&& from) noexcept
    : StateUpdate() {
    *this = ::std::move(from);
  }

  inline StateUpdate& operator=(const StateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateUpdate& operator=(StateUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateUpdate* internal_default_instance() {
    return reinterpret_cast<const StateUpdate*>(
               &_StateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StateUpdate& a, StateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StateUpdate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateUpdate* New() const final {
    return CreateMaybeMessage<StateUpdate>(nullptr);
  }

  StateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateUpdate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateUpdate& from);
  void MergeFrom(const StateUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.StateUpdate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StateUpdate_UpdateType UpdateType;
  static constexpr UpdateType STATE_UPDATE_UPDATE_TYPE_INVALID =
    StateUpdate_UpdateType_STATE_UPDATE_UPDATE_TYPE_INVALID;
  static constexpr UpdateType SNAPSHOT =
    StateUpdate_UpdateType_SNAPSHOT;
  static constexpr UpdateType INCREMENTAL =
    StateUpdate_UpdateType_INCREMENTAL;
  static constexpr UpdateType COMPLETE_STATE =
    StateUpdate_UpdateType_COMPLETE_STATE;
  static constexpr UpdateType PERSISTENT =
    StateUpdate_UpdateType_PERSISTENT;
  static inline bool UpdateType_IsValid(int value) {
    return StateUpdate_UpdateType_IsValid(value);
  }
  static constexpr UpdateType UpdateType_MIN =
    StateUpdate_UpdateType_UpdateType_MIN;
  static constexpr UpdateType UpdateType_MAX =
    StateUpdate_UpdateType_UpdateType_MAX;
  static constexpr int UpdateType_ARRAYSIZE =
    StateUpdate_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateType_descriptor() {
    return StateUpdate_UpdateType_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateType_Name.");
    return StateUpdate_UpdateType_Name(enum_t_value);
  }
  static inline bool UpdateType_Parse(const std::string& name,
      UpdateType* value) {
    return StateUpdate_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUpdatesFieldNumber = 2,
    kUpdateTypeFieldNumber = 1,
  };
  // repeated .xviz.StreamSet updates = 2;
  int updates_size() const;
  private:
  int _internal_updates_size() const;
  public:
  void clear_updates();
  ::xviz::StreamSet* mutable_updates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StreamSet >*
      mutable_updates();
  private:
  const ::xviz::StreamSet& _internal_updates(int index) const;
  ::xviz::StreamSet* _internal_add_updates();
  public:
  const ::xviz::StreamSet& updates(int index) const;
  ::xviz::StreamSet* add_updates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StreamSet >&
      updates() const;

  // .xviz.StateUpdate.UpdateType update_type = 1;
  void clear_update_type();
  ::xviz::StateUpdate_UpdateType update_type() const;
  void set_update_type(::xviz::StateUpdate_UpdateType value);
  private:
  ::xviz::StateUpdate_UpdateType _internal_update_type() const;
  void _internal_set_update_type(::xviz::StateUpdate_UpdateType value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.StateUpdate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StreamSet > updates_;
  int update_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class TransformLogDone :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.TransformLogDone) */ {
 public:
  TransformLogDone();
  virtual ~TransformLogDone();

  TransformLogDone(const TransformLogDone& from);
  TransformLogDone(TransformLogDone&& from) noexcept
    : TransformLogDone() {
    *this = ::std::move(from);
  }

  inline TransformLogDone& operator=(const TransformLogDone& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformLogDone& operator=(TransformLogDone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransformLogDone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformLogDone* internal_default_instance() {
    return reinterpret_cast<const TransformLogDone*>(
               &_TransformLogDone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TransformLogDone& a, TransformLogDone& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformLogDone* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransformLogDone* New() const final {
    return CreateMaybeMessage<TransformLogDone>(nullptr);
  }

  TransformLogDone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransformLogDone>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransformLogDone& from);
  void MergeFrom(const TransformLogDone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformLogDone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.TransformLogDone";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:xviz.TransformLogDone)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class TransformPointInTime :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.TransformPointInTime) */ {
 public:
  TransformPointInTime();
  virtual ~TransformPointInTime();

  TransformPointInTime(const TransformPointInTime& from);
  TransformPointInTime(TransformPointInTime&& from) noexcept
    : TransformPointInTime() {
    *this = ::std::move(from);
  }

  inline TransformPointInTime& operator=(const TransformPointInTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransformPointInTime& operator=(TransformPointInTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransformPointInTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransformPointInTime* internal_default_instance() {
    return reinterpret_cast<const TransformPointInTime*>(
               &_TransformPointInTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TransformPointInTime& a, TransformPointInTime& b) {
    a.Swap(&b);
  }
  inline void Swap(TransformPointInTime* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransformPointInTime* New() const final {
    return CreateMaybeMessage<TransformPointInTime>(nullptr);
  }

  TransformPointInTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransformPointInTime>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransformPointInTime& from);
  void MergeFrom(const TransformPointInTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransformPointInTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.TransformPointInTime";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDesiredStreamsFieldNumber = 3,
    kIdFieldNumber = 1,
    kQueryTimestampFieldNumber = 2,
  };
  // repeated string desired_streams = 3;
  int desired_streams_size() const;
  private:
  int _internal_desired_streams_size() const;
  public:
  void clear_desired_streams();
  const std::string& desired_streams(int index) const;
  std::string* mutable_desired_streams(int index);
  void set_desired_streams(int index, const std::string& value);
  void set_desired_streams(int index, std::string&& value);
  void set_desired_streams(int index, const char* value);
  void set_desired_streams(int index, const char* value, size_t size);
  std::string* add_desired_streams();
  void add_desired_streams(const std::string& value);
  void add_desired_streams(std::string&& value);
  void add_desired_streams(const char* value);
  void add_desired_streams(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& desired_streams() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_desired_streams();
  private:
  const std::string& _internal_desired_streams(int index) const;
  std::string* _internal_add_desired_streams();
  public:

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // double query_timestamp = 2;
  void clear_query_timestamp();
  double query_timestamp() const;
  void set_query_timestamp(double value);
  private:
  double _internal_query_timestamp() const;
  void _internal_set_query_timestamp(double value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.TransformPointInTime)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> desired_streams_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  double query_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class Reconfigure :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.Reconfigure) */ {
 public:
  Reconfigure();
  virtual ~Reconfigure();

  Reconfigure(const Reconfigure& from);
  Reconfigure(Reconfigure&& from) noexcept
    : Reconfigure() {
    *this = ::std::move(from);
  }

  inline Reconfigure& operator=(const Reconfigure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reconfigure& operator=(Reconfigure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Reconfigure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reconfigure* internal_default_instance() {
    return reinterpret_cast<const Reconfigure*>(
               &_Reconfigure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Reconfigure& a, Reconfigure& b) {
    a.Swap(&b);
  }
  inline void Swap(Reconfigure* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reconfigure* New() const final {
    return CreateMaybeMessage<Reconfigure>(nullptr);
  }

  Reconfigure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reconfigure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Reconfigure& from);
  void MergeFrom(const Reconfigure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reconfigure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.Reconfigure";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Reconfigure_UpdateType UpdateType;
  static constexpr UpdateType RECONFIGURE_UPDATE_TYPE_INVALID =
    Reconfigure_UpdateType_RECONFIGURE_UPDATE_TYPE_INVALID;
  static constexpr UpdateType DELTA =
    Reconfigure_UpdateType_DELTA;
  static constexpr UpdateType FULL =
    Reconfigure_UpdateType_FULL;
  static inline bool UpdateType_IsValid(int value) {
    return Reconfigure_UpdateType_IsValid(value);
  }
  static constexpr UpdateType UpdateType_MIN =
    Reconfigure_UpdateType_UpdateType_MIN;
  static constexpr UpdateType UpdateType_MAX =
    Reconfigure_UpdateType_UpdateType_MAX;
  static constexpr int UpdateType_ARRAYSIZE =
    Reconfigure_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UpdateType_descriptor() {
    return Reconfigure_UpdateType_descriptor();
  }
  template<typename T>
  static inline const std::string& UpdateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UpdateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UpdateType_Name.");
    return Reconfigure_UpdateType_Name(enum_t_value);
  }
  static inline bool UpdateType_Parse(const std::string& name,
      UpdateType* value) {
    return Reconfigure_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kConfigUpdateFieldNumber = 2,
    kUpdateTypeFieldNumber = 1,
  };
  // .google.protobuf.Struct config_update = 2;
  bool has_config_update() const;
  private:
  bool _internal_has_config_update() const;
  public:
  void clear_config_update();
  const PROTOBUF_NAMESPACE_ID::Struct& config_update() const;
  PROTOBUF_NAMESPACE_ID::Struct* release_config_update();
  PROTOBUF_NAMESPACE_ID::Struct* mutable_config_update();
  void set_allocated_config_update(PROTOBUF_NAMESPACE_ID::Struct* config_update);
  private:
  const PROTOBUF_NAMESPACE_ID::Struct& _internal_config_update() const;
  PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_config_update();
  public:

  // .xviz.Reconfigure.UpdateType update_type = 1;
  void clear_update_type();
  ::xviz::Reconfigure_UpdateType update_type() const;
  void set_update_type(::xviz::Reconfigure_UpdateType value);
  private:
  ::xviz::Reconfigure_UpdateType _internal_update_type() const;
  void _internal_set_update_type(::xviz::Reconfigure_UpdateType value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.Reconfigure)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  PROTOBUF_NAMESPACE_ID::Struct* config_update_;
  int update_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class Metadata_StreamsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_StreamsEntry_DoNotUse, 
    std::string, ::xviz::StreamMetadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_StreamsEntry_DoNotUse, 
    std::string, ::xviz::StreamMetadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Metadata_StreamsEntry_DoNotUse();
  Metadata_StreamsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_StreamsEntry_DoNotUse& other);
  static const Metadata_StreamsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_StreamsEntry_DoNotUse*>(&_Metadata_StreamsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xviz.Metadata.StreamsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[6];
  }

  public:
};

// -------------------------------------------------------------------

class Metadata_CamerasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_CamerasEntry_DoNotUse, 
    std::string, ::xviz::CameraInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_CamerasEntry_DoNotUse, 
    std::string, ::xviz::CameraInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Metadata_CamerasEntry_DoNotUse();
  Metadata_CamerasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_CamerasEntry_DoNotUse& other);
  static const Metadata_CamerasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_CamerasEntry_DoNotUse*>(&_Metadata_CamerasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xviz.Metadata.CamerasEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[7];
  }

  public:
};

// -------------------------------------------------------------------

class Metadata_StreamAliasesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_StreamAliasesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_StreamAliasesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Metadata_StreamAliasesEntry_DoNotUse();
  Metadata_StreamAliasesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_StreamAliasesEntry_DoNotUse& other);
  static const Metadata_StreamAliasesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_StreamAliasesEntry_DoNotUse*>(&_Metadata_StreamAliasesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xviz.Metadata.StreamAliasesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xviz.Metadata.StreamAliasesEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[8];
  }

  public:
};

// -------------------------------------------------------------------

class Metadata_UiConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_UiConfigEntry_DoNotUse, 
    std::string, ::xviz::UIPanelInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Metadata_UiConfigEntry_DoNotUse, 
    std::string, ::xviz::UIPanelInfo,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Metadata_UiConfigEntry_DoNotUse();
  Metadata_UiConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Metadata_UiConfigEntry_DoNotUse& other);
  static const Metadata_UiConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Metadata_UiConfigEntry_DoNotUse*>(&_Metadata_UiConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xviz.Metadata.UiConfigEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[9];
  }

  public:
};

// -------------------------------------------------------------------

class Metadata :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.Metadata) */ {
 public:
  Metadata();
  virtual ~Metadata();

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Metadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Metadata* New() const final {
    return CreateMaybeMessage<Metadata>(nullptr);
  }

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.Metadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 2,
    kCamerasFieldNumber = 3,
    kStreamAliasesFieldNumber = 4,
    kUiConfigFieldNumber = 5,
    kVersionFieldNumber = 1,
    kLogInfoFieldNumber = 6,
  };
  // map<string, .xviz.StreamMetadata> streams = 2;
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >&
      _internal_streams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >*
      _internal_mutable_streams();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >&
      streams() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >*
      mutable_streams();

  // map<string, .xviz.CameraInfo> cameras = 3;
  int cameras_size() const;
  private:
  int _internal_cameras_size() const;
  public:
  void clear_cameras();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >&
      _internal_cameras() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >*
      _internal_mutable_cameras();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >&
      cameras() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >*
      mutable_cameras();

  // map<string, string> stream_aliases = 4;
  int stream_aliases_size() const;
  private:
  int _internal_stream_aliases_size() const;
  public:
  void clear_stream_aliases();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_stream_aliases() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_stream_aliases();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      stream_aliases() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_stream_aliases();

  // map<string, .xviz.UIPanelInfo> ui_config = 5;
  int ui_config_size() const;
  private:
  int _internal_ui_config_size() const;
  public:
  void clear_ui_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >&
      _internal_ui_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >*
      _internal_mutable_ui_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >&
      ui_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >*
      mutable_ui_config();

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .xviz.LogInfo log_info = 6;
  bool has_log_info() const;
  private:
  bool _internal_has_log_info() const;
  public:
  void clear_log_info();
  const ::xviz::LogInfo& log_info() const;
  ::xviz::LogInfo* release_log_info();
  ::xviz::LogInfo* mutable_log_info();
  void set_allocated_log_info(::xviz::LogInfo* log_info);
  private:
  const ::xviz::LogInfo& _internal_log_info() const;
  ::xviz::LogInfo* _internal_mutable_log_info();
  public:

  // @@protoc_insertion_point(class_scope:xviz.Metadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_StreamsEntry_DoNotUse,
      std::string, ::xviz::StreamMetadata,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > streams_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_CamerasEntry_DoNotUse,
      std::string, ::xviz::CameraInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > cameras_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_StreamAliasesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > stream_aliases_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Metadata_UiConfigEntry_DoNotUse,
      std::string, ::xviz::UIPanelInfo,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE,
      0 > ui_config_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::xviz::LogInfo* log_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class Error :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(nullptr);
  }

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.Error";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:xviz.Error)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class StreamMetadata :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.StreamMetadata) */ {
 public:
  StreamMetadata();
  virtual ~StreamMetadata();

  StreamMetadata(const StreamMetadata& from);
  StreamMetadata(StreamMetadata&& from) noexcept
    : StreamMetadata() {
    *this = ::std::move(from);
  }

  inline StreamMetadata& operator=(const StreamMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamMetadata& operator=(StreamMetadata&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StreamMetadata& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamMetadata* internal_default_instance() {
    return reinterpret_cast<const StreamMetadata*>(
               &_StreamMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StreamMetadata& a, StreamMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamMetadata* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamMetadata* New() const final {
    return CreateMaybeMessage<StreamMetadata>(nullptr);
  }

  StreamMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamMetadata>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamMetadata& from);
  void MergeFrom(const StreamMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamMetadata* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.StreamMetadata";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StreamMetadata_Category Category;
  static constexpr Category STREAM_METADATA_CATEGORY_INVALID =
    StreamMetadata_Category_STREAM_METADATA_CATEGORY_INVALID;
  static constexpr Category PRIMITIVE =
    StreamMetadata_Category_PRIMITIVE;
  static constexpr Category TIME_SERIES =
    StreamMetadata_Category_TIME_SERIES;
  static constexpr Category VARIABLE =
    StreamMetadata_Category_VARIABLE;
  static constexpr Category ANNOTATION =
    StreamMetadata_Category_ANNOTATION;
  static constexpr Category FUTURE_INSTANCE =
    StreamMetadata_Category_FUTURE_INSTANCE;
  static constexpr Category POSE =
    StreamMetadata_Category_POSE;
  static constexpr Category UI_PRIMITIVE =
    StreamMetadata_Category_UI_PRIMITIVE;
  static inline bool Category_IsValid(int value) {
    return StreamMetadata_Category_IsValid(value);
  }
  static constexpr Category Category_MIN =
    StreamMetadata_Category_Category_MIN;
  static constexpr Category Category_MAX =
    StreamMetadata_Category_Category_MAX;
  static constexpr int Category_ARRAYSIZE =
    StreamMetadata_Category_Category_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Category_descriptor() {
    return StreamMetadata_Category_descriptor();
  }
  template<typename T>
  static inline const std::string& Category_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Category>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Category_Name.");
    return StreamMetadata_Category_Name(enum_t_value);
  }
  static inline bool Category_Parse(const std::string& name,
      Category* value) {
    return StreamMetadata_Category_Parse(name, value);
  }

  typedef StreamMetadata_ScalarType ScalarType;
  static constexpr ScalarType STREAM_METADATA_SCALAR_TYPE_INVALID =
    StreamMetadata_ScalarType_STREAM_METADATA_SCALAR_TYPE_INVALID;
  static constexpr ScalarType FLOAT =
    StreamMetadata_ScalarType_FLOAT;
  static constexpr ScalarType INT32 =
    StreamMetadata_ScalarType_INT32;
  static constexpr ScalarType STRING =
    StreamMetadata_ScalarType_STRING;
  static constexpr ScalarType BOOL =
    StreamMetadata_ScalarType_BOOL;
  static inline bool ScalarType_IsValid(int value) {
    return StreamMetadata_ScalarType_IsValid(value);
  }
  static constexpr ScalarType ScalarType_MIN =
    StreamMetadata_ScalarType_ScalarType_MIN;
  static constexpr ScalarType ScalarType_MAX =
    StreamMetadata_ScalarType_ScalarType_MAX;
  static constexpr int ScalarType_ARRAYSIZE =
    StreamMetadata_ScalarType_ScalarType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScalarType_descriptor() {
    return StreamMetadata_ScalarType_descriptor();
  }
  template<typename T>
  static inline const std::string& ScalarType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScalarType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScalarType_Name.");
    return StreamMetadata_ScalarType_Name(enum_t_value);
  }
  static inline bool ScalarType_Parse(const std::string& name,
      ScalarType* value) {
    return StreamMetadata_ScalarType_Parse(name, value);
  }

  typedef StreamMetadata_PrimitiveType PrimitiveType;
  static constexpr PrimitiveType STREAM_METADATA_PRIMITIVE_TYPE_INVALID =
    StreamMetadata_PrimitiveType_STREAM_METADATA_PRIMITIVE_TYPE_INVALID;
  static constexpr PrimitiveType CIRCLE =
    StreamMetadata_PrimitiveType_CIRCLE;
  static constexpr PrimitiveType IMAGE =
    StreamMetadata_PrimitiveType_IMAGE;
  static constexpr PrimitiveType POINT =
    StreamMetadata_PrimitiveType_POINT;
  static constexpr PrimitiveType POLYGON =
    StreamMetadata_PrimitiveType_POLYGON;
  static constexpr PrimitiveType POLYLINE =
    StreamMetadata_PrimitiveType_POLYLINE;
  static constexpr PrimitiveType STADIUM =
    StreamMetadata_PrimitiveType_STADIUM;
  static constexpr PrimitiveType TEXT =
    StreamMetadata_PrimitiveType_TEXT;
  static inline bool PrimitiveType_IsValid(int value) {
    return StreamMetadata_PrimitiveType_IsValid(value);
  }
  static constexpr PrimitiveType PrimitiveType_MIN =
    StreamMetadata_PrimitiveType_PrimitiveType_MIN;
  static constexpr PrimitiveType PrimitiveType_MAX =
    StreamMetadata_PrimitiveType_PrimitiveType_MAX;
  static constexpr int PrimitiveType_ARRAYSIZE =
    StreamMetadata_PrimitiveType_PrimitiveType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PrimitiveType_descriptor() {
    return StreamMetadata_PrimitiveType_descriptor();
  }
  template<typename T>
  static inline const std::string& PrimitiveType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PrimitiveType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PrimitiveType_Name.");
    return StreamMetadata_PrimitiveType_Name(enum_t_value);
  }
  static inline bool PrimitiveType_Parse(const std::string& name,
      PrimitiveType* value) {
    return StreamMetadata_PrimitiveType_Parse(name, value);
  }

  typedef StreamMetadata_UIPrimitiveType UIPrimitiveType;
  static constexpr UIPrimitiveType STREAM_METADATA_UI_PRIMITIVE_TYPE_INVALID =
    StreamMetadata_UIPrimitiveType_STREAM_METADATA_UI_PRIMITIVE_TYPE_INVALID;
  static constexpr UIPrimitiveType TREETABLE =
    StreamMetadata_UIPrimitiveType_TREETABLE;
  static inline bool UIPrimitiveType_IsValid(int value) {
    return StreamMetadata_UIPrimitiveType_IsValid(value);
  }
  static constexpr UIPrimitiveType UIPrimitiveType_MIN =
    StreamMetadata_UIPrimitiveType_UIPrimitiveType_MIN;
  static constexpr UIPrimitiveType UIPrimitiveType_MAX =
    StreamMetadata_UIPrimitiveType_UIPrimitiveType_MAX;
  static constexpr int UIPrimitiveType_ARRAYSIZE =
    StreamMetadata_UIPrimitiveType_UIPrimitiveType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  UIPrimitiveType_descriptor() {
    return StreamMetadata_UIPrimitiveType_descriptor();
  }
  template<typename T>
  static inline const std::string& UIPrimitiveType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, UIPrimitiveType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function UIPrimitiveType_Name.");
    return StreamMetadata_UIPrimitiveType_Name(enum_t_value);
  }
  static inline bool UIPrimitiveType_Parse(const std::string& name,
      UIPrimitiveType* value) {
    return StreamMetadata_UIPrimitiveType_Parse(name, value);
  }

  typedef StreamMetadata_AnnotationType AnnotationType;
  static constexpr AnnotationType STREAM_METADATA_ANNOTATION_TYPE_INVALID =
    StreamMetadata_AnnotationType_STREAM_METADATA_ANNOTATION_TYPE_INVALID;
  static constexpr AnnotationType VISUAL =
    StreamMetadata_AnnotationType_VISUAL;
  static inline bool AnnotationType_IsValid(int value) {
    return StreamMetadata_AnnotationType_IsValid(value);
  }
  static constexpr AnnotationType AnnotationType_MIN =
    StreamMetadata_AnnotationType_AnnotationType_MIN;
  static constexpr AnnotationType AnnotationType_MAX =
    StreamMetadata_AnnotationType_AnnotationType_MAX;
  static constexpr int AnnotationType_ARRAYSIZE =
    StreamMetadata_AnnotationType_AnnotationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AnnotationType_descriptor() {
    return StreamMetadata_AnnotationType_descriptor();
  }
  template<typename T>
  static inline const std::string& AnnotationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AnnotationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AnnotationType_Name.");
    return StreamMetadata_AnnotationType_Name(enum_t_value);
  }
  static inline bool AnnotationType_Parse(const std::string& name,
      AnnotationType* value) {
    return StreamMetadata_AnnotationType_Parse(name, value);
  }

  typedef StreamMetadata_CoordinateType CoordinateType;
  static constexpr CoordinateType STREAM_METADATA_COORDINATE_TYPE_INVALID =
    StreamMetadata_CoordinateType_STREAM_METADATA_COORDINATE_TYPE_INVALID;
  static constexpr CoordinateType GEOGRAPHIC =
    StreamMetadata_CoordinateType_GEOGRAPHIC;
  static constexpr CoordinateType IDENTITY =
    StreamMetadata_CoordinateType_IDENTITY;
  static constexpr CoordinateType DYNAMIC =
    StreamMetadata_CoordinateType_DYNAMIC;
  static constexpr CoordinateType VEHICLE_RELATIVE =
    StreamMetadata_CoordinateType_VEHICLE_RELATIVE;
  static inline bool CoordinateType_IsValid(int value) {
    return StreamMetadata_CoordinateType_IsValid(value);
  }
  static constexpr CoordinateType CoordinateType_MIN =
    StreamMetadata_CoordinateType_CoordinateType_MIN;
  static constexpr CoordinateType CoordinateType_MAX =
    StreamMetadata_CoordinateType_CoordinateType_MAX;
  static constexpr int CoordinateType_ARRAYSIZE =
    StreamMetadata_CoordinateType_CoordinateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CoordinateType_descriptor() {
    return StreamMetadata_CoordinateType_descriptor();
  }
  template<typename T>
  static inline const std::string& CoordinateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CoordinateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CoordinateType_Name.");
    return StreamMetadata_CoordinateType_Name(enum_t_value);
  }
  static inline bool CoordinateType_Parse(const std::string& name,
      CoordinateType* value) {
    return StreamMetadata_CoordinateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStyleClassesFieldNumber = 9,
    kTransformFieldNumber = 11,
    kSourceFieldNumber = 1,
    kUnitsFieldNumber = 2,
    kTransformCallbackFieldNumber = 12,
    kStreamStyleFieldNumber = 8,
    kCategoryFieldNumber = 3,
    kScalarTypeFieldNumber = 4,
    kPrimitiveTypeFieldNumber = 5,
    kUiPrimitiveTypeFieldNumber = 6,
    kAnnotationTypeFieldNumber = 7,
    kCoordinateFieldNumber = 10,
  };
  // repeated .xviz.StyleClass style_classes = 9;
  int style_classes_size() const;
  private:
  int _internal_style_classes_size() const;
  public:
  void clear_style_classes();
  ::xviz::StyleClass* mutable_style_classes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StyleClass >*
      mutable_style_classes();
  private:
  const ::xviz::StyleClass& _internal_style_classes(int index) const;
  ::xviz::StyleClass* _internal_add_style_classes();
  public:
  const ::xviz::StyleClass& style_classes(int index) const;
  ::xviz::StyleClass* add_style_classes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StyleClass >&
      style_classes() const;

  // repeated double transform = 11;
  int transform_size() const;
  private:
  int _internal_transform_size() const;
  public:
  void clear_transform();
  private:
  double _internal_transform(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_transform() const;
  void _internal_add_transform(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_transform();
  public:
  double transform(int index) const;
  void set_transform(int index, double value);
  void add_transform(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      transform() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_transform();

  // string source = 1;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // string units = 2;
  void clear_units();
  const std::string& units() const;
  void set_units(const std::string& value);
  void set_units(std::string&& value);
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  std::string* mutable_units();
  std::string* release_units();
  void set_allocated_units(std::string* units);
  private:
  const std::string& _internal_units() const;
  void _internal_set_units(const std::string& value);
  std::string* _internal_mutable_units();
  public:

  // string transform_callback = 12;
  void clear_transform_callback();
  const std::string& transform_callback() const;
  void set_transform_callback(const std::string& value);
  void set_transform_callback(std::string&& value);
  void set_transform_callback(const char* value);
  void set_transform_callback(const char* value, size_t size);
  std::string* mutable_transform_callback();
  std::string* release_transform_callback();
  void set_allocated_transform_callback(std::string* transform_callback);
  private:
  const std::string& _internal_transform_callback() const;
  void _internal_set_transform_callback(const std::string& value);
  std::string* _internal_mutable_transform_callback();
  public:

  // .xviz.StyleStreamValue stream_style = 8;
  bool has_stream_style() const;
  private:
  bool _internal_has_stream_style() const;
  public:
  void clear_stream_style();
  const ::xviz::StyleStreamValue& stream_style() const;
  ::xviz::StyleStreamValue* release_stream_style();
  ::xviz::StyleStreamValue* mutable_stream_style();
  void set_allocated_stream_style(::xviz::StyleStreamValue* stream_style);
  private:
  const ::xviz::StyleStreamValue& _internal_stream_style() const;
  ::xviz::StyleStreamValue* _internal_mutable_stream_style();
  public:

  // .xviz.StreamMetadata.Category category = 3;
  void clear_category();
  ::xviz::StreamMetadata_Category category() const;
  void set_category(::xviz::StreamMetadata_Category value);
  private:
  ::xviz::StreamMetadata_Category _internal_category() const;
  void _internal_set_category(::xviz::StreamMetadata_Category value);
  public:

  // .xviz.StreamMetadata.ScalarType scalar_type = 4;
  void clear_scalar_type();
  ::xviz::StreamMetadata_ScalarType scalar_type() const;
  void set_scalar_type(::xviz::StreamMetadata_ScalarType value);
  private:
  ::xviz::StreamMetadata_ScalarType _internal_scalar_type() const;
  void _internal_set_scalar_type(::xviz::StreamMetadata_ScalarType value);
  public:

  // .xviz.StreamMetadata.PrimitiveType primitive_type = 5;
  void clear_primitive_type();
  ::xviz::StreamMetadata_PrimitiveType primitive_type() const;
  void set_primitive_type(::xviz::StreamMetadata_PrimitiveType value);
  private:
  ::xviz::StreamMetadata_PrimitiveType _internal_primitive_type() const;
  void _internal_set_primitive_type(::xviz::StreamMetadata_PrimitiveType value);
  public:

  // .xviz.StreamMetadata.UIPrimitiveType ui_primitive_type = 6;
  void clear_ui_primitive_type();
  ::xviz::StreamMetadata_UIPrimitiveType ui_primitive_type() const;
  void set_ui_primitive_type(::xviz::StreamMetadata_UIPrimitiveType value);
  private:
  ::xviz::StreamMetadata_UIPrimitiveType _internal_ui_primitive_type() const;
  void _internal_set_ui_primitive_type(::xviz::StreamMetadata_UIPrimitiveType value);
  public:

  // .xviz.StreamMetadata.AnnotationType annotation_type = 7;
  void clear_annotation_type();
  ::xviz::StreamMetadata_AnnotationType annotation_type() const;
  void set_annotation_type(::xviz::StreamMetadata_AnnotationType value);
  private:
  ::xviz::StreamMetadata_AnnotationType _internal_annotation_type() const;
  void _internal_set_annotation_type(::xviz::StreamMetadata_AnnotationType value);
  public:

  // .xviz.StreamMetadata.CoordinateType coordinate = 10;
  void clear_coordinate();
  ::xviz::StreamMetadata_CoordinateType coordinate() const;
  void set_coordinate(::xviz::StreamMetadata_CoordinateType value);
  private:
  ::xviz::StreamMetadata_CoordinateType _internal_coordinate() const;
  void _internal_set_coordinate(::xviz::StreamMetadata_CoordinateType value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.StreamMetadata)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StyleClass > style_classes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > transform_;
  mutable std::atomic<int> _transform_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr units_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transform_callback_;
  ::xviz::StyleStreamValue* stream_style_;
  int category_;
  int scalar_type_;
  int primitive_type_;
  int ui_primitive_type_;
  int annotation_type_;
  int coordinate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class CameraInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.CameraInfo) */ {
 public:
  CameraInfo();
  virtual ~CameraInfo();

  CameraInfo(const CameraInfo& from);
  CameraInfo(CameraInfo&& from) noexcept
    : CameraInfo() {
    *this = ::std::move(from);
  }

  inline CameraInfo& operator=(const CameraInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CameraInfo& operator=(CameraInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CameraInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CameraInfo* internal_default_instance() {
    return reinterpret_cast<const CameraInfo*>(
               &_CameraInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CameraInfo& a, CameraInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CameraInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CameraInfo* New() const final {
    return CreateMaybeMessage<CameraInfo>(nullptr);
  }

  CameraInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CameraInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CameraInfo& from);
  void MergeFrom(const CameraInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CameraInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.CameraInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVehiclePositionFieldNumber = 3,
    kVehicleOrientationFieldNumber = 4,
    kRectificationProjectionFieldNumber = 7,
    kGlProjectionFieldNumber = 8,
    kHumanNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kPixelWidthFieldNumber = 5,
    kPixelHeightFieldNumber = 6,
  };
  // repeated double vehicle_position = 3;
  int vehicle_position_size() const;
  private:
  int _internal_vehicle_position_size() const;
  public:
  void clear_vehicle_position();
  private:
  double _internal_vehicle_position(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_vehicle_position() const;
  void _internal_add_vehicle_position(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_vehicle_position();
  public:
  double vehicle_position(int index) const;
  void set_vehicle_position(int index, double value);
  void add_vehicle_position(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      vehicle_position() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_vehicle_position();

  // repeated double vehicle_orientation = 4;
  int vehicle_orientation_size() const;
  private:
  int _internal_vehicle_orientation_size() const;
  public:
  void clear_vehicle_orientation();
  private:
  double _internal_vehicle_orientation(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_vehicle_orientation() const;
  void _internal_add_vehicle_orientation(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_vehicle_orientation();
  public:
  double vehicle_orientation(int index) const;
  void set_vehicle_orientation(int index, double value);
  void add_vehicle_orientation(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      vehicle_orientation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_vehicle_orientation();

  // repeated double rectification_projection = 7;
  int rectification_projection_size() const;
  private:
  int _internal_rectification_projection_size() const;
  public:
  void clear_rectification_projection();
  private:
  double _internal_rectification_projection(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_rectification_projection() const;
  void _internal_add_rectification_projection(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_rectification_projection();
  public:
  double rectification_projection(int index) const;
  void set_rectification_projection(int index, double value);
  void add_rectification_projection(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      rectification_projection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_rectification_projection();

  // repeated double gl_projection = 8;
  int gl_projection_size() const;
  private:
  int _internal_gl_projection_size() const;
  public:
  void clear_gl_projection();
  private:
  double _internal_gl_projection(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_gl_projection() const;
  void _internal_add_gl_projection(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_gl_projection();
  public:
  double gl_projection(int index) const;
  void set_gl_projection(int index, double value);
  void add_gl_projection(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      gl_projection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_gl_projection();

  // string human_name = 1;
  void clear_human_name();
  const std::string& human_name() const;
  void set_human_name(const std::string& value);
  void set_human_name(std::string&& value);
  void set_human_name(const char* value);
  void set_human_name(const char* value, size_t size);
  std::string* mutable_human_name();
  std::string* release_human_name();
  void set_allocated_human_name(std::string* human_name);
  private:
  const std::string& _internal_human_name() const;
  void _internal_set_human_name(const std::string& value);
  std::string* _internal_mutable_human_name();
  public:

  // string source = 2;
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // double pixel_width = 5;
  void clear_pixel_width();
  double pixel_width() const;
  void set_pixel_width(double value);
  private:
  double _internal_pixel_width() const;
  void _internal_set_pixel_width(double value);
  public:

  // double pixel_height = 6;
  void clear_pixel_height();
  double pixel_height() const;
  void set_pixel_height(double value);
  private:
  double _internal_pixel_height() const;
  void _internal_set_pixel_height(double value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.CameraInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > vehicle_position_;
  mutable std::atomic<int> _vehicle_position_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > vehicle_orientation_;
  mutable std::atomic<int> _vehicle_orientation_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > rectification_projection_;
  mutable std::atomic<int> _rectification_projection_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > gl_projection_;
  mutable std::atomic<int> _gl_projection_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr human_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  double pixel_width_;
  double pixel_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class UIPanelInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.UIPanelInfo) */ {
 public:
  UIPanelInfo();
  virtual ~UIPanelInfo();

  UIPanelInfo(const UIPanelInfo& from);
  UIPanelInfo(UIPanelInfo&& from) noexcept
    : UIPanelInfo() {
    *this = ::std::move(from);
  }

  inline UIPanelInfo& operator=(const UIPanelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIPanelInfo& operator=(UIPanelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UIPanelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UIPanelInfo* internal_default_instance() {
    return reinterpret_cast<const UIPanelInfo*>(
               &_UIPanelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UIPanelInfo& a, UIPanelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(UIPanelInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UIPanelInfo* New() const final {
    return CreateMaybeMessage<UIPanelInfo>(nullptr);
  }

  UIPanelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UIPanelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UIPanelInfo& from);
  void MergeFrom(const UIPanelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIPanelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.UIPanelInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChildrenFieldNumber = 2,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // repeated .xviz.UIPanel children = 2;
  int children_size() const;
  private:
  int _internal_children_size() const;
  public:
  void clear_children();
  ::xviz::UIPanel* mutable_children(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::UIPanel >*
      mutable_children();
  private:
  const ::xviz::UIPanel& _internal_children(int index) const;
  ::xviz::UIPanel* _internal_add_children();
  public:
  const ::xviz::UIPanel& children(int index) const;
  ::xviz::UIPanel* add_children();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::UIPanel >&
      children() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string type = 3;
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:xviz.UIPanelInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::UIPanel > children_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// -------------------------------------------------------------------

class LogInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xviz.LogInfo) */ {
 public:
  LogInfo();
  virtual ~LogInfo();

  LogInfo(const LogInfo& from);
  LogInfo(LogInfo&& from) noexcept
    : LogInfo() {
    *this = ::std::move(from);
  }

  inline LogInfo& operator=(const LogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogInfo& operator=(LogInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogInfo* internal_default_instance() {
    return reinterpret_cast<const LogInfo*>(
               &_LogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LogInfo& a, LogInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LogInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogInfo* New() const final {
    return CreateMaybeMessage<LogInfo>(nullptr);
  }

  LogInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogInfo& from);
  void MergeFrom(const LogInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xviz.LogInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_session_2eproto);
    return ::descriptor_table_session_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // double start_time = 1;
  void clear_start_time();
  double start_time() const;
  void set_start_time(double value);
  private:
  double _internal_start_time() const;
  void _internal_set_start_time(double value);
  public:

  // double end_time = 2;
  void clear_end_time();
  double end_time() const;
  void set_end_time(double value);
  private:
  double _internal_end_time() const;
  void _internal_set_end_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:xviz.LogInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  double start_time_;
  double end_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_session_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Start

// string version = 1;
inline void Start::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Start::version() const {
  // @@protoc_insertion_point(field_get:xviz.Start.version)
  return _internal_version();
}
inline void Start::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:xviz.Start.version)
}
inline std::string* Start::mutable_version() {
  // @@protoc_insertion_point(field_mutable:xviz.Start.version)
  return _internal_mutable_version();
}
inline const std::string& Start::_internal_version() const {
  return version_.GetNoArena();
}
inline void Start::_internal_set_version(const std::string& value) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Start::set_version(std::string&& value) {
  
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.Start.version)
}
inline void Start::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.Start.version)
}
inline void Start::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.Start.version)
}
inline std::string* Start::_internal_mutable_version() {
  
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Start::release_version() {
  // @@protoc_insertion_point(field_release:xviz.Start.version)
  
  return version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Start::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:xviz.Start.version)
}

// string profile = 2;
inline void Start::clear_profile() {
  profile_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Start::profile() const {
  // @@protoc_insertion_point(field_get:xviz.Start.profile)
  return _internal_profile();
}
inline void Start::set_profile(const std::string& value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:xviz.Start.profile)
}
inline std::string* Start::mutable_profile() {
  // @@protoc_insertion_point(field_mutable:xviz.Start.profile)
  return _internal_mutable_profile();
}
inline const std::string& Start::_internal_profile() const {
  return profile_.GetNoArena();
}
inline void Start::_internal_set_profile(const std::string& value) {
  
  profile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Start::set_profile(std::string&& value) {
  
  profile_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.Start.profile)
}
inline void Start::set_profile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  profile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.Start.profile)
}
inline void Start::set_profile(const char* value, size_t size) {
  
  profile_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.Start.profile)
}
inline std::string* Start::_internal_mutable_profile() {
  
  return profile_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Start::release_profile() {
  // @@protoc_insertion_point(field_release:xviz.Start.profile)
  
  return profile_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Start::set_allocated_profile(std::string* profile) {
  if (profile != nullptr) {
    
  } else {
    
  }
  profile_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), profile);
  // @@protoc_insertion_point(field_set_allocated:xviz.Start.profile)
}

// .xviz.SessionType session_type = 3;
inline void Start::clear_session_type() {
  session_type_ = 0;
}
inline ::xviz::SessionType Start::_internal_session_type() const {
  return static_cast< ::xviz::SessionType >(session_type_);
}
inline ::xviz::SessionType Start::session_type() const {
  // @@protoc_insertion_point(field_get:xviz.Start.session_type)
  return _internal_session_type();
}
inline void Start::_internal_set_session_type(::xviz::SessionType value) {
  
  session_type_ = value;
}
inline void Start::set_session_type(::xviz::SessionType value) {
  _internal_set_session_type(value);
  // @@protoc_insertion_point(field_set:xviz.Start.session_type)
}

// .xviz.Start.MessageFormat message_format = 4;
inline void Start::clear_message_format() {
  message_format_ = 0;
}
inline ::xviz::Start_MessageFormat Start::_internal_message_format() const {
  return static_cast< ::xviz::Start_MessageFormat >(message_format_);
}
inline ::xviz::Start_MessageFormat Start::message_format() const {
  // @@protoc_insertion_point(field_get:xviz.Start.message_format)
  return _internal_message_format();
}
inline void Start::_internal_set_message_format(::xviz::Start_MessageFormat value) {
  
  message_format_ = value;
}
inline void Start::set_message_format(::xviz::Start_MessageFormat value) {
  _internal_set_message_format(value);
  // @@protoc_insertion_point(field_set:xviz.Start.message_format)
}

// string log = 5;
inline void Start::clear_log() {
  log_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Start::log() const {
  // @@protoc_insertion_point(field_get:xviz.Start.log)
  return _internal_log();
}
inline void Start::set_log(const std::string& value) {
  _internal_set_log(value);
  // @@protoc_insertion_point(field_set:xviz.Start.log)
}
inline std::string* Start::mutable_log() {
  // @@protoc_insertion_point(field_mutable:xviz.Start.log)
  return _internal_mutable_log();
}
inline const std::string& Start::_internal_log() const {
  return log_.GetNoArena();
}
inline void Start::_internal_set_log(const std::string& value) {
  
  log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Start::set_log(std::string&& value) {
  
  log_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.Start.log)
}
inline void Start::set_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.Start.log)
}
inline void Start::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.Start.log)
}
inline std::string* Start::_internal_mutable_log() {
  
  return log_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Start::release_log() {
  // @@protoc_insertion_point(field_release:xviz.Start.log)
  
  return log_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Start::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:xviz.Start.log)
}

// -------------------------------------------------------------------

// TransformLog

// string id = 1;
inline void TransformLog::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransformLog::id() const {
  // @@protoc_insertion_point(field_get:xviz.TransformLog.id)
  return _internal_id();
}
inline void TransformLog::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:xviz.TransformLog.id)
}
inline std::string* TransformLog::mutable_id() {
  // @@protoc_insertion_point(field_mutable:xviz.TransformLog.id)
  return _internal_mutable_id();
}
inline const std::string& TransformLog::_internal_id() const {
  return id_.GetNoArena();
}
inline void TransformLog::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TransformLog::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.TransformLog.id)
}
inline void TransformLog::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.TransformLog.id)
}
inline void TransformLog::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.TransformLog.id)
}
inline std::string* TransformLog::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransformLog::release_id() {
  // @@protoc_insertion_point(field_release:xviz.TransformLog.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransformLog::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:xviz.TransformLog.id)
}

// double start_timestamp = 2;
inline void TransformLog::clear_start_timestamp() {
  start_timestamp_ = 0;
}
inline double TransformLog::_internal_start_timestamp() const {
  return start_timestamp_;
}
inline double TransformLog::start_timestamp() const {
  // @@protoc_insertion_point(field_get:xviz.TransformLog.start_timestamp)
  return _internal_start_timestamp();
}
inline void TransformLog::_internal_set_start_timestamp(double value) {
  
  start_timestamp_ = value;
}
inline void TransformLog::set_start_timestamp(double value) {
  _internal_set_start_timestamp(value);
  // @@protoc_insertion_point(field_set:xviz.TransformLog.start_timestamp)
}

// double end_timestamp = 3;
inline void TransformLog::clear_end_timestamp() {
  end_timestamp_ = 0;
}
inline double TransformLog::_internal_end_timestamp() const {
  return end_timestamp_;
}
inline double TransformLog::end_timestamp() const {
  // @@protoc_insertion_point(field_get:xviz.TransformLog.end_timestamp)
  return _internal_end_timestamp();
}
inline void TransformLog::_internal_set_end_timestamp(double value) {
  
  end_timestamp_ = value;
}
inline void TransformLog::set_end_timestamp(double value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:xviz.TransformLog.end_timestamp)
}

// repeated string desired_streams = 4;
inline int TransformLog::_internal_desired_streams_size() const {
  return desired_streams_.size();
}
inline int TransformLog::desired_streams_size() const {
  return _internal_desired_streams_size();
}
inline void TransformLog::clear_desired_streams() {
  desired_streams_.Clear();
}
inline std::string* TransformLog::add_desired_streams() {
  // @@protoc_insertion_point(field_add_mutable:xviz.TransformLog.desired_streams)
  return _internal_add_desired_streams();
}
inline const std::string& TransformLog::_internal_desired_streams(int index) const {
  return desired_streams_.Get(index);
}
inline const std::string& TransformLog::desired_streams(int index) const {
  // @@protoc_insertion_point(field_get:xviz.TransformLog.desired_streams)
  return _internal_desired_streams(index);
}
inline std::string* TransformLog::mutable_desired_streams(int index) {
  // @@protoc_insertion_point(field_mutable:xviz.TransformLog.desired_streams)
  return desired_streams_.Mutable(index);
}
inline void TransformLog::set_desired_streams(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:xviz.TransformLog.desired_streams)
  desired_streams_.Mutable(index)->assign(value);
}
inline void TransformLog::set_desired_streams(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:xviz.TransformLog.desired_streams)
  desired_streams_.Mutable(index)->assign(std::move(value));
}
inline void TransformLog::set_desired_streams(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_streams_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xviz.TransformLog.desired_streams)
}
inline void TransformLog::set_desired_streams(int index, const char* value, size_t size) {
  desired_streams_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xviz.TransformLog.desired_streams)
}
inline std::string* TransformLog::_internal_add_desired_streams() {
  return desired_streams_.Add();
}
inline void TransformLog::add_desired_streams(const std::string& value) {
  desired_streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xviz.TransformLog.desired_streams)
}
inline void TransformLog::add_desired_streams(std::string&& value) {
  desired_streams_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xviz.TransformLog.desired_streams)
}
inline void TransformLog::add_desired_streams(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xviz.TransformLog.desired_streams)
}
inline void TransformLog::add_desired_streams(const char* value, size_t size) {
  desired_streams_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xviz.TransformLog.desired_streams)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransformLog::desired_streams() const {
  // @@protoc_insertion_point(field_list:xviz.TransformLog.desired_streams)
  return desired_streams_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransformLog::mutable_desired_streams() {
  // @@protoc_insertion_point(field_mutable_list:xviz.TransformLog.desired_streams)
  return &desired_streams_;
}

// -------------------------------------------------------------------

// StateUpdate

// .xviz.StateUpdate.UpdateType update_type = 1;
inline void StateUpdate::clear_update_type() {
  update_type_ = 0;
}
inline ::xviz::StateUpdate_UpdateType StateUpdate::_internal_update_type() const {
  return static_cast< ::xviz::StateUpdate_UpdateType >(update_type_);
}
inline ::xviz::StateUpdate_UpdateType StateUpdate::update_type() const {
  // @@protoc_insertion_point(field_get:xviz.StateUpdate.update_type)
  return _internal_update_type();
}
inline void StateUpdate::_internal_set_update_type(::xviz::StateUpdate_UpdateType value) {
  
  update_type_ = value;
}
inline void StateUpdate::set_update_type(::xviz::StateUpdate_UpdateType value) {
  _internal_set_update_type(value);
  // @@protoc_insertion_point(field_set:xviz.StateUpdate.update_type)
}

// repeated .xviz.StreamSet updates = 2;
inline int StateUpdate::_internal_updates_size() const {
  return updates_.size();
}
inline int StateUpdate::updates_size() const {
  return _internal_updates_size();
}
inline ::xviz::StreamSet* StateUpdate::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:xviz.StateUpdate.updates)
  return updates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StreamSet >*
StateUpdate::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:xviz.StateUpdate.updates)
  return &updates_;
}
inline const ::xviz::StreamSet& StateUpdate::_internal_updates(int index) const {
  return updates_.Get(index);
}
inline const ::xviz::StreamSet& StateUpdate::updates(int index) const {
  // @@protoc_insertion_point(field_get:xviz.StateUpdate.updates)
  return _internal_updates(index);
}
inline ::xviz::StreamSet* StateUpdate::_internal_add_updates() {
  return updates_.Add();
}
inline ::xviz::StreamSet* StateUpdate::add_updates() {
  // @@protoc_insertion_point(field_add:xviz.StateUpdate.updates)
  return _internal_add_updates();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StreamSet >&
StateUpdate::updates() const {
  // @@protoc_insertion_point(field_list:xviz.StateUpdate.updates)
  return updates_;
}

// -------------------------------------------------------------------

// TransformLogDone

// string id = 1;
inline void TransformLogDone::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransformLogDone::id() const {
  // @@protoc_insertion_point(field_get:xviz.TransformLogDone.id)
  return _internal_id();
}
inline void TransformLogDone::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:xviz.TransformLogDone.id)
}
inline std::string* TransformLogDone::mutable_id() {
  // @@protoc_insertion_point(field_mutable:xviz.TransformLogDone.id)
  return _internal_mutable_id();
}
inline const std::string& TransformLogDone::_internal_id() const {
  return id_.GetNoArena();
}
inline void TransformLogDone::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TransformLogDone::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.TransformLogDone.id)
}
inline void TransformLogDone::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.TransformLogDone.id)
}
inline void TransformLogDone::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.TransformLogDone.id)
}
inline std::string* TransformLogDone::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransformLogDone::release_id() {
  // @@protoc_insertion_point(field_release:xviz.TransformLogDone.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransformLogDone::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:xviz.TransformLogDone.id)
}

// -------------------------------------------------------------------

// TransformPointInTime

// string id = 1;
inline void TransformPointInTime::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& TransformPointInTime::id() const {
  // @@protoc_insertion_point(field_get:xviz.TransformPointInTime.id)
  return _internal_id();
}
inline void TransformPointInTime::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:xviz.TransformPointInTime.id)
}
inline std::string* TransformPointInTime::mutable_id() {
  // @@protoc_insertion_point(field_mutable:xviz.TransformPointInTime.id)
  return _internal_mutable_id();
}
inline const std::string& TransformPointInTime::_internal_id() const {
  return id_.GetNoArena();
}
inline void TransformPointInTime::_internal_set_id(const std::string& value) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void TransformPointInTime::set_id(std::string&& value) {
  
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.TransformPointInTime.id)
}
inline void TransformPointInTime::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.TransformPointInTime.id)
}
inline void TransformPointInTime::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.TransformPointInTime.id)
}
inline std::string* TransformPointInTime::_internal_mutable_id() {
  
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TransformPointInTime::release_id() {
  // @@protoc_insertion_point(field_release:xviz.TransformPointInTime.id)
  
  return id_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TransformPointInTime::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:xviz.TransformPointInTime.id)
}

// double query_timestamp = 2;
inline void TransformPointInTime::clear_query_timestamp() {
  query_timestamp_ = 0;
}
inline double TransformPointInTime::_internal_query_timestamp() const {
  return query_timestamp_;
}
inline double TransformPointInTime::query_timestamp() const {
  // @@protoc_insertion_point(field_get:xviz.TransformPointInTime.query_timestamp)
  return _internal_query_timestamp();
}
inline void TransformPointInTime::_internal_set_query_timestamp(double value) {
  
  query_timestamp_ = value;
}
inline void TransformPointInTime::set_query_timestamp(double value) {
  _internal_set_query_timestamp(value);
  // @@protoc_insertion_point(field_set:xviz.TransformPointInTime.query_timestamp)
}

// repeated string desired_streams = 3;
inline int TransformPointInTime::_internal_desired_streams_size() const {
  return desired_streams_.size();
}
inline int TransformPointInTime::desired_streams_size() const {
  return _internal_desired_streams_size();
}
inline void TransformPointInTime::clear_desired_streams() {
  desired_streams_.Clear();
}
inline std::string* TransformPointInTime::add_desired_streams() {
  // @@protoc_insertion_point(field_add_mutable:xviz.TransformPointInTime.desired_streams)
  return _internal_add_desired_streams();
}
inline const std::string& TransformPointInTime::_internal_desired_streams(int index) const {
  return desired_streams_.Get(index);
}
inline const std::string& TransformPointInTime::desired_streams(int index) const {
  // @@protoc_insertion_point(field_get:xviz.TransformPointInTime.desired_streams)
  return _internal_desired_streams(index);
}
inline std::string* TransformPointInTime::mutable_desired_streams(int index) {
  // @@protoc_insertion_point(field_mutable:xviz.TransformPointInTime.desired_streams)
  return desired_streams_.Mutable(index);
}
inline void TransformPointInTime::set_desired_streams(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:xviz.TransformPointInTime.desired_streams)
  desired_streams_.Mutable(index)->assign(value);
}
inline void TransformPointInTime::set_desired_streams(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:xviz.TransformPointInTime.desired_streams)
  desired_streams_.Mutable(index)->assign(std::move(value));
}
inline void TransformPointInTime::set_desired_streams(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_streams_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:xviz.TransformPointInTime.desired_streams)
}
inline void TransformPointInTime::set_desired_streams(int index, const char* value, size_t size) {
  desired_streams_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:xviz.TransformPointInTime.desired_streams)
}
inline std::string* TransformPointInTime::_internal_add_desired_streams() {
  return desired_streams_.Add();
}
inline void TransformPointInTime::add_desired_streams(const std::string& value) {
  desired_streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:xviz.TransformPointInTime.desired_streams)
}
inline void TransformPointInTime::add_desired_streams(std::string&& value) {
  desired_streams_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:xviz.TransformPointInTime.desired_streams)
}
inline void TransformPointInTime::add_desired_streams(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_streams_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:xviz.TransformPointInTime.desired_streams)
}
inline void TransformPointInTime::add_desired_streams(const char* value, size_t size) {
  desired_streams_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:xviz.TransformPointInTime.desired_streams)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransformPointInTime::desired_streams() const {
  // @@protoc_insertion_point(field_list:xviz.TransformPointInTime.desired_streams)
  return desired_streams_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransformPointInTime::mutable_desired_streams() {
  // @@protoc_insertion_point(field_mutable_list:xviz.TransformPointInTime.desired_streams)
  return &desired_streams_;
}

// -------------------------------------------------------------------

// Reconfigure

// .xviz.Reconfigure.UpdateType update_type = 1;
inline void Reconfigure::clear_update_type() {
  update_type_ = 0;
}
inline ::xviz::Reconfigure_UpdateType Reconfigure::_internal_update_type() const {
  return static_cast< ::xviz::Reconfigure_UpdateType >(update_type_);
}
inline ::xviz::Reconfigure_UpdateType Reconfigure::update_type() const {
  // @@protoc_insertion_point(field_get:xviz.Reconfigure.update_type)
  return _internal_update_type();
}
inline void Reconfigure::_internal_set_update_type(::xviz::Reconfigure_UpdateType value) {
  
  update_type_ = value;
}
inline void Reconfigure::set_update_type(::xviz::Reconfigure_UpdateType value) {
  _internal_set_update_type(value);
  // @@protoc_insertion_point(field_set:xviz.Reconfigure.update_type)
}

// .google.protobuf.Struct config_update = 2;
inline bool Reconfigure::_internal_has_config_update() const {
  return this != internal_default_instance() && config_update_ != nullptr;
}
inline bool Reconfigure::has_config_update() const {
  return _internal_has_config_update();
}
inline const PROTOBUF_NAMESPACE_ID::Struct& Reconfigure::_internal_config_update() const {
  const PROTOBUF_NAMESPACE_ID::Struct* p = config_update_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Struct*>(
      &PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Struct& Reconfigure::config_update() const {
  // @@protoc_insertion_point(field_get:xviz.Reconfigure.config_update)
  return _internal_config_update();
}
inline PROTOBUF_NAMESPACE_ID::Struct* Reconfigure::release_config_update() {
  // @@protoc_insertion_point(field_release:xviz.Reconfigure.config_update)
  
  PROTOBUF_NAMESPACE_ID::Struct* temp = config_update_;
  config_update_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Struct* Reconfigure::_internal_mutable_config_update() {
  
  if (config_update_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Struct>(GetArenaNoVirtual());
    config_update_ = p;
  }
  return config_update_;
}
inline PROTOBUF_NAMESPACE_ID::Struct* Reconfigure::mutable_config_update() {
  // @@protoc_insertion_point(field_mutable:xviz.Reconfigure.config_update)
  return _internal_mutable_config_update();
}
inline void Reconfigure::set_allocated_config_update(PROTOBUF_NAMESPACE_ID::Struct* config_update) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_update_);
  }
  if (config_update) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_update)->GetArena();
    if (message_arena != submessage_arena) {
      config_update = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_update, submessage_arena);
    }
    
  } else {
    
  }
  config_update_ = config_update;
  // @@protoc_insertion_point(field_set_allocated:xviz.Reconfigure.config_update)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Metadata

// string version = 1;
inline void Metadata::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Metadata::version() const {
  // @@protoc_insertion_point(field_get:xviz.Metadata.version)
  return _internal_version();
}
inline void Metadata::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:xviz.Metadata.version)
}
inline std::string* Metadata::mutable_version() {
  // @@protoc_insertion_point(field_mutable:xviz.Metadata.version)
  return _internal_mutable_version();
}
inline const std::string& Metadata::_internal_version() const {
  return version_.GetNoArena();
}
inline void Metadata::_internal_set_version(const std::string& value) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Metadata::set_version(std::string&& value) {
  
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.Metadata.version)
}
inline void Metadata::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.Metadata.version)
}
inline void Metadata::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.Metadata.version)
}
inline std::string* Metadata::_internal_mutable_version() {
  
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Metadata::release_version() {
  // @@protoc_insertion_point(field_release:xviz.Metadata.version)
  
  return version_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Metadata::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:xviz.Metadata.version)
}

// map<string, .xviz.StreamMetadata> streams = 2;
inline int Metadata::_internal_streams_size() const {
  return streams_.size();
}
inline int Metadata::streams_size() const {
  return _internal_streams_size();
}
inline void Metadata::clear_streams() {
  streams_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >&
Metadata::_internal_streams() const {
  return streams_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >&
Metadata::streams() const {
  // @@protoc_insertion_point(field_map:xviz.Metadata.streams)
  return _internal_streams();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >*
Metadata::_internal_mutable_streams() {
  return streams_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::StreamMetadata >*
Metadata::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_map:xviz.Metadata.streams)
  return _internal_mutable_streams();
}

// map<string, .xviz.CameraInfo> cameras = 3;
inline int Metadata::_internal_cameras_size() const {
  return cameras_.size();
}
inline int Metadata::cameras_size() const {
  return _internal_cameras_size();
}
inline void Metadata::clear_cameras() {
  cameras_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >&
Metadata::_internal_cameras() const {
  return cameras_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >&
Metadata::cameras() const {
  // @@protoc_insertion_point(field_map:xviz.Metadata.cameras)
  return _internal_cameras();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >*
Metadata::_internal_mutable_cameras() {
  return cameras_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::CameraInfo >*
Metadata::mutable_cameras() {
  // @@protoc_insertion_point(field_mutable_map:xviz.Metadata.cameras)
  return _internal_mutable_cameras();
}

// map<string, string> stream_aliases = 4;
inline int Metadata::_internal_stream_aliases_size() const {
  return stream_aliases_.size();
}
inline int Metadata::stream_aliases_size() const {
  return _internal_stream_aliases_size();
}
inline void Metadata::clear_stream_aliases() {
  stream_aliases_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::_internal_stream_aliases() const {
  return stream_aliases_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Metadata::stream_aliases() const {
  // @@protoc_insertion_point(field_map:xviz.Metadata.stream_aliases)
  return _internal_stream_aliases();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::_internal_mutable_stream_aliases() {
  return stream_aliases_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Metadata::mutable_stream_aliases() {
  // @@protoc_insertion_point(field_mutable_map:xviz.Metadata.stream_aliases)
  return _internal_mutable_stream_aliases();
}

// map<string, .xviz.UIPanelInfo> ui_config = 5;
inline int Metadata::_internal_ui_config_size() const {
  return ui_config_.size();
}
inline int Metadata::ui_config_size() const {
  return _internal_ui_config_size();
}
inline void Metadata::clear_ui_config() {
  ui_config_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >&
Metadata::_internal_ui_config() const {
  return ui_config_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >&
Metadata::ui_config() const {
  // @@protoc_insertion_point(field_map:xviz.Metadata.ui_config)
  return _internal_ui_config();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >*
Metadata::_internal_mutable_ui_config() {
  return ui_config_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xviz::UIPanelInfo >*
Metadata::mutable_ui_config() {
  // @@protoc_insertion_point(field_mutable_map:xviz.Metadata.ui_config)
  return _internal_mutable_ui_config();
}

// .xviz.LogInfo log_info = 6;
inline bool Metadata::_internal_has_log_info() const {
  return this != internal_default_instance() && log_info_ != nullptr;
}
inline bool Metadata::has_log_info() const {
  return _internal_has_log_info();
}
inline void Metadata::clear_log_info() {
  if (GetArenaNoVirtual() == nullptr && log_info_ != nullptr) {
    delete log_info_;
  }
  log_info_ = nullptr;
}
inline const ::xviz::LogInfo& Metadata::_internal_log_info() const {
  const ::xviz::LogInfo* p = log_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::xviz::LogInfo*>(
      &::xviz::_LogInfo_default_instance_);
}
inline const ::xviz::LogInfo& Metadata::log_info() const {
  // @@protoc_insertion_point(field_get:xviz.Metadata.log_info)
  return _internal_log_info();
}
inline ::xviz::LogInfo* Metadata::release_log_info() {
  // @@protoc_insertion_point(field_release:xviz.Metadata.log_info)
  
  ::xviz::LogInfo* temp = log_info_;
  log_info_ = nullptr;
  return temp;
}
inline ::xviz::LogInfo* Metadata::_internal_mutable_log_info() {
  
  if (log_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::xviz::LogInfo>(GetArenaNoVirtual());
    log_info_ = p;
  }
  return log_info_;
}
inline ::xviz::LogInfo* Metadata::mutable_log_info() {
  // @@protoc_insertion_point(field_mutable:xviz.Metadata.log_info)
  return _internal_mutable_log_info();
}
inline void Metadata::set_allocated_log_info(::xviz::LogInfo* log_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete log_info_;
  }
  if (log_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      log_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_info, submessage_arena);
    }
    
  } else {
    
  }
  log_info_ = log_info;
  // @@protoc_insertion_point(field_set_allocated:xviz.Metadata.log_info)
}

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:xviz.Error.message)
  return _internal_message();
}
inline void Error::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:xviz.Error.message)
}
inline std::string* Error::mutable_message() {
  // @@protoc_insertion_point(field_mutable:xviz.Error.message)
  return _internal_mutable_message();
}
inline const std::string& Error::_internal_message() const {
  return message_.GetNoArena();
}
inline void Error::_internal_set_message(const std::string& value) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Error::set_message(std::string&& value) {
  
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.Error.message)
}
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.Error.message)
}
inline std::string* Error::_internal_mutable_message() {
  
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:xviz.Error.message)
  
  return message_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:xviz.Error.message)
}

// -------------------------------------------------------------------

// StreamMetadata

// string source = 1;
inline void StreamMetadata::clear_source() {
  source_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StreamMetadata::source() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.source)
  return _internal_source();
}
inline void StreamMetadata::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.source)
}
inline std::string* StreamMetadata::mutable_source() {
  // @@protoc_insertion_point(field_mutable:xviz.StreamMetadata.source)
  return _internal_mutable_source();
}
inline const std::string& StreamMetadata::_internal_source() const {
  return source_.GetNoArena();
}
inline void StreamMetadata::_internal_set_source(const std::string& value) {
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StreamMetadata::set_source(std::string&& value) {
  
  source_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.StreamMetadata.source)
}
inline void StreamMetadata::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.StreamMetadata.source)
}
inline void StreamMetadata::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.StreamMetadata.source)
}
inline std::string* StreamMetadata::_internal_mutable_source() {
  
  return source_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamMetadata::release_source() {
  // @@protoc_insertion_point(field_release:xviz.StreamMetadata.source)
  
  return source_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamMetadata::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:xviz.StreamMetadata.source)
}

// string units = 2;
inline void StreamMetadata::clear_units() {
  units_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StreamMetadata::units() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.units)
  return _internal_units();
}
inline void StreamMetadata::set_units(const std::string& value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.units)
}
inline std::string* StreamMetadata::mutable_units() {
  // @@protoc_insertion_point(field_mutable:xviz.StreamMetadata.units)
  return _internal_mutable_units();
}
inline const std::string& StreamMetadata::_internal_units() const {
  return units_.GetNoArena();
}
inline void StreamMetadata::_internal_set_units(const std::string& value) {
  
  units_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StreamMetadata::set_units(std::string&& value) {
  
  units_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.StreamMetadata.units)
}
inline void StreamMetadata::set_units(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  units_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.StreamMetadata.units)
}
inline void StreamMetadata::set_units(const char* value, size_t size) {
  
  units_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.StreamMetadata.units)
}
inline std::string* StreamMetadata::_internal_mutable_units() {
  
  return units_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamMetadata::release_units() {
  // @@protoc_insertion_point(field_release:xviz.StreamMetadata.units)
  
  return units_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamMetadata::set_allocated_units(std::string* units) {
  if (units != nullptr) {
    
  } else {
    
  }
  units_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:xviz.StreamMetadata.units)
}

// .xviz.StreamMetadata.Category category = 3;
inline void StreamMetadata::clear_category() {
  category_ = 0;
}
inline ::xviz::StreamMetadata_Category StreamMetadata::_internal_category() const {
  return static_cast< ::xviz::StreamMetadata_Category >(category_);
}
inline ::xviz::StreamMetadata_Category StreamMetadata::category() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.category)
  return _internal_category();
}
inline void StreamMetadata::_internal_set_category(::xviz::StreamMetadata_Category value) {
  
  category_ = value;
}
inline void StreamMetadata::set_category(::xviz::StreamMetadata_Category value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.category)
}

// .xviz.StreamMetadata.ScalarType scalar_type = 4;
inline void StreamMetadata::clear_scalar_type() {
  scalar_type_ = 0;
}
inline ::xviz::StreamMetadata_ScalarType StreamMetadata::_internal_scalar_type() const {
  return static_cast< ::xviz::StreamMetadata_ScalarType >(scalar_type_);
}
inline ::xviz::StreamMetadata_ScalarType StreamMetadata::scalar_type() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.scalar_type)
  return _internal_scalar_type();
}
inline void StreamMetadata::_internal_set_scalar_type(::xviz::StreamMetadata_ScalarType value) {
  
  scalar_type_ = value;
}
inline void StreamMetadata::set_scalar_type(::xviz::StreamMetadata_ScalarType value) {
  _internal_set_scalar_type(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.scalar_type)
}

// .xviz.StreamMetadata.PrimitiveType primitive_type = 5;
inline void StreamMetadata::clear_primitive_type() {
  primitive_type_ = 0;
}
inline ::xviz::StreamMetadata_PrimitiveType StreamMetadata::_internal_primitive_type() const {
  return static_cast< ::xviz::StreamMetadata_PrimitiveType >(primitive_type_);
}
inline ::xviz::StreamMetadata_PrimitiveType StreamMetadata::primitive_type() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.primitive_type)
  return _internal_primitive_type();
}
inline void StreamMetadata::_internal_set_primitive_type(::xviz::StreamMetadata_PrimitiveType value) {
  
  primitive_type_ = value;
}
inline void StreamMetadata::set_primitive_type(::xviz::StreamMetadata_PrimitiveType value) {
  _internal_set_primitive_type(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.primitive_type)
}

// .xviz.StreamMetadata.UIPrimitiveType ui_primitive_type = 6;
inline void StreamMetadata::clear_ui_primitive_type() {
  ui_primitive_type_ = 0;
}
inline ::xviz::StreamMetadata_UIPrimitiveType StreamMetadata::_internal_ui_primitive_type() const {
  return static_cast< ::xviz::StreamMetadata_UIPrimitiveType >(ui_primitive_type_);
}
inline ::xviz::StreamMetadata_UIPrimitiveType StreamMetadata::ui_primitive_type() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.ui_primitive_type)
  return _internal_ui_primitive_type();
}
inline void StreamMetadata::_internal_set_ui_primitive_type(::xviz::StreamMetadata_UIPrimitiveType value) {
  
  ui_primitive_type_ = value;
}
inline void StreamMetadata::set_ui_primitive_type(::xviz::StreamMetadata_UIPrimitiveType value) {
  _internal_set_ui_primitive_type(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.ui_primitive_type)
}

// .xviz.StreamMetadata.AnnotationType annotation_type = 7;
inline void StreamMetadata::clear_annotation_type() {
  annotation_type_ = 0;
}
inline ::xviz::StreamMetadata_AnnotationType StreamMetadata::_internal_annotation_type() const {
  return static_cast< ::xviz::StreamMetadata_AnnotationType >(annotation_type_);
}
inline ::xviz::StreamMetadata_AnnotationType StreamMetadata::annotation_type() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.annotation_type)
  return _internal_annotation_type();
}
inline void StreamMetadata::_internal_set_annotation_type(::xviz::StreamMetadata_AnnotationType value) {
  
  annotation_type_ = value;
}
inline void StreamMetadata::set_annotation_type(::xviz::StreamMetadata_AnnotationType value) {
  _internal_set_annotation_type(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.annotation_type)
}

// .xviz.StyleStreamValue stream_style = 8;
inline bool StreamMetadata::_internal_has_stream_style() const {
  return this != internal_default_instance() && stream_style_ != nullptr;
}
inline bool StreamMetadata::has_stream_style() const {
  return _internal_has_stream_style();
}
inline const ::xviz::StyleStreamValue& StreamMetadata::_internal_stream_style() const {
  const ::xviz::StyleStreamValue* p = stream_style_;
  return p != nullptr ? *p : *reinterpret_cast<const ::xviz::StyleStreamValue*>(
      &::xviz::_StyleStreamValue_default_instance_);
}
inline const ::xviz::StyleStreamValue& StreamMetadata::stream_style() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.stream_style)
  return _internal_stream_style();
}
inline ::xviz::StyleStreamValue* StreamMetadata::release_stream_style() {
  // @@protoc_insertion_point(field_release:xviz.StreamMetadata.stream_style)
  
  ::xviz::StyleStreamValue* temp = stream_style_;
  stream_style_ = nullptr;
  return temp;
}
inline ::xviz::StyleStreamValue* StreamMetadata::_internal_mutable_stream_style() {
  
  if (stream_style_ == nullptr) {
    auto* p = CreateMaybeMessage<::xviz::StyleStreamValue>(GetArenaNoVirtual());
    stream_style_ = p;
  }
  return stream_style_;
}
inline ::xviz::StyleStreamValue* StreamMetadata::mutable_stream_style() {
  // @@protoc_insertion_point(field_mutable:xviz.StreamMetadata.stream_style)
  return _internal_mutable_stream_style();
}
inline void StreamMetadata::set_allocated_stream_style(::xviz::StyleStreamValue* stream_style) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_style_);
  }
  if (stream_style) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stream_style = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream_style, submessage_arena);
    }
    
  } else {
    
  }
  stream_style_ = stream_style;
  // @@protoc_insertion_point(field_set_allocated:xviz.StreamMetadata.stream_style)
}

// repeated .xviz.StyleClass style_classes = 9;
inline int StreamMetadata::_internal_style_classes_size() const {
  return style_classes_.size();
}
inline int StreamMetadata::style_classes_size() const {
  return _internal_style_classes_size();
}
inline ::xviz::StyleClass* StreamMetadata::mutable_style_classes(int index) {
  // @@protoc_insertion_point(field_mutable:xviz.StreamMetadata.style_classes)
  return style_classes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StyleClass >*
StreamMetadata::mutable_style_classes() {
  // @@protoc_insertion_point(field_mutable_list:xviz.StreamMetadata.style_classes)
  return &style_classes_;
}
inline const ::xviz::StyleClass& StreamMetadata::_internal_style_classes(int index) const {
  return style_classes_.Get(index);
}
inline const ::xviz::StyleClass& StreamMetadata::style_classes(int index) const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.style_classes)
  return _internal_style_classes(index);
}
inline ::xviz::StyleClass* StreamMetadata::_internal_add_style_classes() {
  return style_classes_.Add();
}
inline ::xviz::StyleClass* StreamMetadata::add_style_classes() {
  // @@protoc_insertion_point(field_add:xviz.StreamMetadata.style_classes)
  return _internal_add_style_classes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::StyleClass >&
StreamMetadata::style_classes() const {
  // @@protoc_insertion_point(field_list:xviz.StreamMetadata.style_classes)
  return style_classes_;
}

// .xviz.StreamMetadata.CoordinateType coordinate = 10;
inline void StreamMetadata::clear_coordinate() {
  coordinate_ = 0;
}
inline ::xviz::StreamMetadata_CoordinateType StreamMetadata::_internal_coordinate() const {
  return static_cast< ::xviz::StreamMetadata_CoordinateType >(coordinate_);
}
inline ::xviz::StreamMetadata_CoordinateType StreamMetadata::coordinate() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.coordinate)
  return _internal_coordinate();
}
inline void StreamMetadata::_internal_set_coordinate(::xviz::StreamMetadata_CoordinateType value) {
  
  coordinate_ = value;
}
inline void StreamMetadata::set_coordinate(::xviz::StreamMetadata_CoordinateType value) {
  _internal_set_coordinate(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.coordinate)
}

// repeated double transform = 11;
inline int StreamMetadata::_internal_transform_size() const {
  return transform_.size();
}
inline int StreamMetadata::transform_size() const {
  return _internal_transform_size();
}
inline void StreamMetadata::clear_transform() {
  transform_.Clear();
}
inline double StreamMetadata::_internal_transform(int index) const {
  return transform_.Get(index);
}
inline double StreamMetadata::transform(int index) const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.transform)
  return _internal_transform(index);
}
inline void StreamMetadata::set_transform(int index, double value) {
  transform_.Set(index, value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.transform)
}
inline void StreamMetadata::_internal_add_transform(double value) {
  transform_.Add(value);
}
inline void StreamMetadata::add_transform(double value) {
  _internal_add_transform(value);
  // @@protoc_insertion_point(field_add:xviz.StreamMetadata.transform)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
StreamMetadata::_internal_transform() const {
  return transform_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
StreamMetadata::transform() const {
  // @@protoc_insertion_point(field_list:xviz.StreamMetadata.transform)
  return _internal_transform();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
StreamMetadata::_internal_mutable_transform() {
  return &transform_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
StreamMetadata::mutable_transform() {
  // @@protoc_insertion_point(field_mutable_list:xviz.StreamMetadata.transform)
  return _internal_mutable_transform();
}

// string transform_callback = 12;
inline void StreamMetadata::clear_transform_callback() {
  transform_callback_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& StreamMetadata::transform_callback() const {
  // @@protoc_insertion_point(field_get:xviz.StreamMetadata.transform_callback)
  return _internal_transform_callback();
}
inline void StreamMetadata::set_transform_callback(const std::string& value) {
  _internal_set_transform_callback(value);
  // @@protoc_insertion_point(field_set:xviz.StreamMetadata.transform_callback)
}
inline std::string* StreamMetadata::mutable_transform_callback() {
  // @@protoc_insertion_point(field_mutable:xviz.StreamMetadata.transform_callback)
  return _internal_mutable_transform_callback();
}
inline const std::string& StreamMetadata::_internal_transform_callback() const {
  return transform_callback_.GetNoArena();
}
inline void StreamMetadata::_internal_set_transform_callback(const std::string& value) {
  
  transform_callback_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void StreamMetadata::set_transform_callback(std::string&& value) {
  
  transform_callback_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.StreamMetadata.transform_callback)
}
inline void StreamMetadata::set_transform_callback(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transform_callback_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.StreamMetadata.transform_callback)
}
inline void StreamMetadata::set_transform_callback(const char* value, size_t size) {
  
  transform_callback_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.StreamMetadata.transform_callback)
}
inline std::string* StreamMetadata::_internal_mutable_transform_callback() {
  
  return transform_callback_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StreamMetadata::release_transform_callback() {
  // @@protoc_insertion_point(field_release:xviz.StreamMetadata.transform_callback)
  
  return transform_callback_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StreamMetadata::set_allocated_transform_callback(std::string* transform_callback) {
  if (transform_callback != nullptr) {
    
  } else {
    
  }
  transform_callback_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transform_callback);
  // @@protoc_insertion_point(field_set_allocated:xviz.StreamMetadata.transform_callback)
}

// -------------------------------------------------------------------

// CameraInfo

// string human_name = 1;
inline void CameraInfo::clear_human_name() {
  human_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CameraInfo::human_name() const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.human_name)
  return _internal_human_name();
}
inline void CameraInfo::set_human_name(const std::string& value) {
  _internal_set_human_name(value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.human_name)
}
inline std::string* CameraInfo::mutable_human_name() {
  // @@protoc_insertion_point(field_mutable:xviz.CameraInfo.human_name)
  return _internal_mutable_human_name();
}
inline const std::string& CameraInfo::_internal_human_name() const {
  return human_name_.GetNoArena();
}
inline void CameraInfo::_internal_set_human_name(const std::string& value) {
  
  human_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CameraInfo::set_human_name(std::string&& value) {
  
  human_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.CameraInfo.human_name)
}
inline void CameraInfo::set_human_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  human_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.CameraInfo.human_name)
}
inline void CameraInfo::set_human_name(const char* value, size_t size) {
  
  human_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.CameraInfo.human_name)
}
inline std::string* CameraInfo::_internal_mutable_human_name() {
  
  return human_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CameraInfo::release_human_name() {
  // @@protoc_insertion_point(field_release:xviz.CameraInfo.human_name)
  
  return human_name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CameraInfo::set_allocated_human_name(std::string* human_name) {
  if (human_name != nullptr) {
    
  } else {
    
  }
  human_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), human_name);
  // @@protoc_insertion_point(field_set_allocated:xviz.CameraInfo.human_name)
}

// string source = 2;
inline void CameraInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& CameraInfo::source() const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.source)
  return _internal_source();
}
inline void CameraInfo::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.source)
}
inline std::string* CameraInfo::mutable_source() {
  // @@protoc_insertion_point(field_mutable:xviz.CameraInfo.source)
  return _internal_mutable_source();
}
inline const std::string& CameraInfo::_internal_source() const {
  return source_.GetNoArena();
}
inline void CameraInfo::_internal_set_source(const std::string& value) {
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void CameraInfo::set_source(std::string&& value) {
  
  source_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.CameraInfo.source)
}
inline void CameraInfo::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.CameraInfo.source)
}
inline void CameraInfo::set_source(const char* value, size_t size) {
  
  source_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.CameraInfo.source)
}
inline std::string* CameraInfo::_internal_mutable_source() {
  
  return source_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CameraInfo::release_source() {
  // @@protoc_insertion_point(field_release:xviz.CameraInfo.source)
  
  return source_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CameraInfo::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    
  } else {
    
  }
  source_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:xviz.CameraInfo.source)
}

// repeated double vehicle_position = 3;
inline int CameraInfo::_internal_vehicle_position_size() const {
  return vehicle_position_.size();
}
inline int CameraInfo::vehicle_position_size() const {
  return _internal_vehicle_position_size();
}
inline void CameraInfo::clear_vehicle_position() {
  vehicle_position_.Clear();
}
inline double CameraInfo::_internal_vehicle_position(int index) const {
  return vehicle_position_.Get(index);
}
inline double CameraInfo::vehicle_position(int index) const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.vehicle_position)
  return _internal_vehicle_position(index);
}
inline void CameraInfo::set_vehicle_position(int index, double value) {
  vehicle_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.vehicle_position)
}
inline void CameraInfo::_internal_add_vehicle_position(double value) {
  vehicle_position_.Add(value);
}
inline void CameraInfo::add_vehicle_position(double value) {
  _internal_add_vehicle_position(value);
  // @@protoc_insertion_point(field_add:xviz.CameraInfo.vehicle_position)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::_internal_vehicle_position() const {
  return vehicle_position_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::vehicle_position() const {
  // @@protoc_insertion_point(field_list:xviz.CameraInfo.vehicle_position)
  return _internal_vehicle_position();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::_internal_mutable_vehicle_position() {
  return &vehicle_position_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::mutable_vehicle_position() {
  // @@protoc_insertion_point(field_mutable_list:xviz.CameraInfo.vehicle_position)
  return _internal_mutable_vehicle_position();
}

// repeated double vehicle_orientation = 4;
inline int CameraInfo::_internal_vehicle_orientation_size() const {
  return vehicle_orientation_.size();
}
inline int CameraInfo::vehicle_orientation_size() const {
  return _internal_vehicle_orientation_size();
}
inline void CameraInfo::clear_vehicle_orientation() {
  vehicle_orientation_.Clear();
}
inline double CameraInfo::_internal_vehicle_orientation(int index) const {
  return vehicle_orientation_.Get(index);
}
inline double CameraInfo::vehicle_orientation(int index) const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.vehicle_orientation)
  return _internal_vehicle_orientation(index);
}
inline void CameraInfo::set_vehicle_orientation(int index, double value) {
  vehicle_orientation_.Set(index, value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.vehicle_orientation)
}
inline void CameraInfo::_internal_add_vehicle_orientation(double value) {
  vehicle_orientation_.Add(value);
}
inline void CameraInfo::add_vehicle_orientation(double value) {
  _internal_add_vehicle_orientation(value);
  // @@protoc_insertion_point(field_add:xviz.CameraInfo.vehicle_orientation)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::_internal_vehicle_orientation() const {
  return vehicle_orientation_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::vehicle_orientation() const {
  // @@protoc_insertion_point(field_list:xviz.CameraInfo.vehicle_orientation)
  return _internal_vehicle_orientation();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::_internal_mutable_vehicle_orientation() {
  return &vehicle_orientation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::mutable_vehicle_orientation() {
  // @@protoc_insertion_point(field_mutable_list:xviz.CameraInfo.vehicle_orientation)
  return _internal_mutable_vehicle_orientation();
}

// double pixel_width = 5;
inline void CameraInfo::clear_pixel_width() {
  pixel_width_ = 0;
}
inline double CameraInfo::_internal_pixel_width() const {
  return pixel_width_;
}
inline double CameraInfo::pixel_width() const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.pixel_width)
  return _internal_pixel_width();
}
inline void CameraInfo::_internal_set_pixel_width(double value) {
  
  pixel_width_ = value;
}
inline void CameraInfo::set_pixel_width(double value) {
  _internal_set_pixel_width(value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.pixel_width)
}

// double pixel_height = 6;
inline void CameraInfo::clear_pixel_height() {
  pixel_height_ = 0;
}
inline double CameraInfo::_internal_pixel_height() const {
  return pixel_height_;
}
inline double CameraInfo::pixel_height() const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.pixel_height)
  return _internal_pixel_height();
}
inline void CameraInfo::_internal_set_pixel_height(double value) {
  
  pixel_height_ = value;
}
inline void CameraInfo::set_pixel_height(double value) {
  _internal_set_pixel_height(value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.pixel_height)
}

// repeated double rectification_projection = 7;
inline int CameraInfo::_internal_rectification_projection_size() const {
  return rectification_projection_.size();
}
inline int CameraInfo::rectification_projection_size() const {
  return _internal_rectification_projection_size();
}
inline void CameraInfo::clear_rectification_projection() {
  rectification_projection_.Clear();
}
inline double CameraInfo::_internal_rectification_projection(int index) const {
  return rectification_projection_.Get(index);
}
inline double CameraInfo::rectification_projection(int index) const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.rectification_projection)
  return _internal_rectification_projection(index);
}
inline void CameraInfo::set_rectification_projection(int index, double value) {
  rectification_projection_.Set(index, value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.rectification_projection)
}
inline void CameraInfo::_internal_add_rectification_projection(double value) {
  rectification_projection_.Add(value);
}
inline void CameraInfo::add_rectification_projection(double value) {
  _internal_add_rectification_projection(value);
  // @@protoc_insertion_point(field_add:xviz.CameraInfo.rectification_projection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::_internal_rectification_projection() const {
  return rectification_projection_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::rectification_projection() const {
  // @@protoc_insertion_point(field_list:xviz.CameraInfo.rectification_projection)
  return _internal_rectification_projection();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::_internal_mutable_rectification_projection() {
  return &rectification_projection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::mutable_rectification_projection() {
  // @@protoc_insertion_point(field_mutable_list:xviz.CameraInfo.rectification_projection)
  return _internal_mutable_rectification_projection();
}

// repeated double gl_projection = 8;
inline int CameraInfo::_internal_gl_projection_size() const {
  return gl_projection_.size();
}
inline int CameraInfo::gl_projection_size() const {
  return _internal_gl_projection_size();
}
inline void CameraInfo::clear_gl_projection() {
  gl_projection_.Clear();
}
inline double CameraInfo::_internal_gl_projection(int index) const {
  return gl_projection_.Get(index);
}
inline double CameraInfo::gl_projection(int index) const {
  // @@protoc_insertion_point(field_get:xviz.CameraInfo.gl_projection)
  return _internal_gl_projection(index);
}
inline void CameraInfo::set_gl_projection(int index, double value) {
  gl_projection_.Set(index, value);
  // @@protoc_insertion_point(field_set:xviz.CameraInfo.gl_projection)
}
inline void CameraInfo::_internal_add_gl_projection(double value) {
  gl_projection_.Add(value);
}
inline void CameraInfo::add_gl_projection(double value) {
  _internal_add_gl_projection(value);
  // @@protoc_insertion_point(field_add:xviz.CameraInfo.gl_projection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::_internal_gl_projection() const {
  return gl_projection_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
CameraInfo::gl_projection() const {
  // @@protoc_insertion_point(field_list:xviz.CameraInfo.gl_projection)
  return _internal_gl_projection();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::_internal_mutable_gl_projection() {
  return &gl_projection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
CameraInfo::mutable_gl_projection() {
  // @@protoc_insertion_point(field_mutable_list:xviz.CameraInfo.gl_projection)
  return _internal_mutable_gl_projection();
}

// -------------------------------------------------------------------

// UIPanelInfo

// string name = 1;
inline void UIPanelInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UIPanelInfo::name() const {
  // @@protoc_insertion_point(field_get:xviz.UIPanelInfo.name)
  return _internal_name();
}
inline void UIPanelInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:xviz.UIPanelInfo.name)
}
inline std::string* UIPanelInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:xviz.UIPanelInfo.name)
  return _internal_mutable_name();
}
inline const std::string& UIPanelInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void UIPanelInfo::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UIPanelInfo::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.UIPanelInfo.name)
}
inline void UIPanelInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.UIPanelInfo.name)
}
inline void UIPanelInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.UIPanelInfo.name)
}
inline std::string* UIPanelInfo::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UIPanelInfo::release_name() {
  // @@protoc_insertion_point(field_release:xviz.UIPanelInfo.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UIPanelInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:xviz.UIPanelInfo.name)
}

// repeated .xviz.UIPanel children = 2;
inline int UIPanelInfo::_internal_children_size() const {
  return children_.size();
}
inline int UIPanelInfo::children_size() const {
  return _internal_children_size();
}
inline ::xviz::UIPanel* UIPanelInfo::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:xviz.UIPanelInfo.children)
  return children_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::UIPanel >*
UIPanelInfo::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:xviz.UIPanelInfo.children)
  return &children_;
}
inline const ::xviz::UIPanel& UIPanelInfo::_internal_children(int index) const {
  return children_.Get(index);
}
inline const ::xviz::UIPanel& UIPanelInfo::children(int index) const {
  // @@protoc_insertion_point(field_get:xviz.UIPanelInfo.children)
  return _internal_children(index);
}
inline ::xviz::UIPanel* UIPanelInfo::_internal_add_children() {
  return children_.Add();
}
inline ::xviz::UIPanel* UIPanelInfo::add_children() {
  // @@protoc_insertion_point(field_add:xviz.UIPanelInfo.children)
  return _internal_add_children();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xviz::UIPanel >&
UIPanelInfo::children() const {
  // @@protoc_insertion_point(field_list:xviz.UIPanelInfo.children)
  return children_;
}

// string type = 3;
inline void UIPanelInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& UIPanelInfo::type() const {
  // @@protoc_insertion_point(field_get:xviz.UIPanelInfo.type)
  return _internal_type();
}
inline void UIPanelInfo::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:xviz.UIPanelInfo.type)
}
inline std::string* UIPanelInfo::mutable_type() {
  // @@protoc_insertion_point(field_mutable:xviz.UIPanelInfo.type)
  return _internal_mutable_type();
}
inline const std::string& UIPanelInfo::_internal_type() const {
  return type_.GetNoArena();
}
inline void UIPanelInfo::_internal_set_type(const std::string& value) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void UIPanelInfo::set_type(std::string&& value) {
  
  type_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xviz.UIPanelInfo.type)
}
inline void UIPanelInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xviz.UIPanelInfo.type)
}
inline void UIPanelInfo::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xviz.UIPanelInfo.type)
}
inline std::string* UIPanelInfo::_internal_mutable_type() {
  
  return type_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UIPanelInfo::release_type() {
  // @@protoc_insertion_point(field_release:xviz.UIPanelInfo.type)
  
  return type_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UIPanelInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:xviz.UIPanelInfo.type)
}

// -------------------------------------------------------------------

// LogInfo

// double start_time = 1;
inline void LogInfo::clear_start_time() {
  start_time_ = 0;
}
inline double LogInfo::_internal_start_time() const {
  return start_time_;
}
inline double LogInfo::start_time() const {
  // @@protoc_insertion_point(field_get:xviz.LogInfo.start_time)
  return _internal_start_time();
}
inline void LogInfo::_internal_set_start_time(double value) {
  
  start_time_ = value;
}
inline void LogInfo::set_start_time(double value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:xviz.LogInfo.start_time)
}

// double end_time = 2;
inline void LogInfo::clear_end_time() {
  end_time_ = 0;
}
inline double LogInfo::_internal_end_time() const {
  return end_time_;
}
inline double LogInfo::end_time() const {
  // @@protoc_insertion_point(field_get:xviz.LogInfo.end_time)
  return _internal_end_time();
}
inline void LogInfo::_internal_set_end_time(double value) {
  
  end_time_ = value;
}
inline void LogInfo::set_end_time(double value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:xviz.LogInfo.end_time)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xviz

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::xviz::Start_MessageFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::Start_MessageFormat>() {
  return ::xviz::Start_MessageFormat_descriptor();
}
template <> struct is_proto_enum< ::xviz::StateUpdate_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StateUpdate_UpdateType>() {
  return ::xviz::StateUpdate_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::xviz::Reconfigure_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::Reconfigure_UpdateType>() {
  return ::xviz::Reconfigure_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_Category> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_Category>() {
  return ::xviz::StreamMetadata_Category_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_ScalarType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_ScalarType>() {
  return ::xviz::StreamMetadata_ScalarType_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_PrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_PrimitiveType>() {
  return ::xviz::StreamMetadata_PrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_UIPrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_UIPrimitiveType>() {
  return ::xviz::StreamMetadata_UIPrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_AnnotationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_AnnotationType>() {
  return ::xviz::StreamMetadata_AnnotationType_descriptor();
}
template <> struct is_proto_enum< ::xviz::StreamMetadata_CoordinateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::StreamMetadata_CoordinateType>() {
  return ::xviz::StreamMetadata_CoordinateType_descriptor();
}
template <> struct is_proto_enum< ::xviz::SessionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xviz::SessionType>() {
  return ::xviz::SessionType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_session_2eproto
